#!/usr/bin/env python3
"""
FLLC - OSINT & RECONNAISSANCE SUITE
==========================================

COMPREHENSIVE OPEN SOURCE INTELLIGENCE GATHERING TOOL
Includes: Target Reconnaissance, People Search, Infrastructure Mapping

⚠️  LEGAL WARNING - AUTHORIZED USE ONLY ⚠️

This tool performs:
- Open Source Intelligence (OSINT) gathering
- Target reconnaissance and enumeration
- People and organization research
- Infrastructure mapping
- Network stress testing (authorized targets only)

LEGAL NOTICE:
- OSINT gathering from public sources is generally legal
- DDoS/stress testing requires EXPLICIT WRITTEN AUTHORIZATION
- Unauthorized network attacks are ILLEGAL
- Only use against:
  1. Your own infrastructure
  2. Authorized client systems
  3. Bug bounty programs with defined scope
  4. Training environments

FLLC
Government-Cleared Security Operations
"""

import requests
import socket
import json
import sys
import os
import re
import time
import threading
from datetime import datetime
from urllib.parse import urljoin, urlparse, quote
from bs4 import BeautifulSoup
import dns.resolver
from concurrent.futures import ThreadPoolExecutor, as_completed
import hashlib
import base64

# Suppress SSL warnings
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Try to import consolidated lists (generated by list_consolidator.py)
try:
    from consolidated_lists import SUBDOMAINS as CONSOLIDATED_SUBDOMAINS
    _HAS_CONSOLIDATED = True
except ImportError:
    _HAS_CONSOLIDATED = False
    CONSOLIDATED_SUBDOMAINS = []

class Colors:
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    GREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

class OSINTReconSuite:
    def __init__(self, target=None, person=None, authorized=False):
        self.target = target
        self.person = person
        self.authorized = authorized
        self.results = {
            'target': target,
            'person': person,
            'timestamp': datetime.now().isoformat(),
            'operator': 'FLLC Security Operations',
            'findings': [],
            'emails': [],
            'phone_numbers': [],
            'social_media': {},
            'domains': [],
            'subdomains': [],
            'ip_addresses': [],
            'technologies': [],
            'employees': [],
            'breaches': [],
            'leaked_data': []
        }
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
    
    def print_banner(self):
        banner = f"""
{Colors.CYAN}===============================================================
    FLLC - OSINT & RECONNAISSANCE SUITE v1.0
    COMPREHENSIVE INTELLIGENCE GATHERING FRAMEWORK
==============================================================={Colors.ENDC}

{Colors.WARNING}[!] LEGAL WARNING [!]{Colors.ENDC}
This tool gathers publicly available information (OSINT)
Stress testing requires EXPLICIT WRITTEN AUTHORIZATION

{Colors.FAIL}UNAUTHORIZED USE MAY BE ILLEGAL{Colors.ENDC}
- DDoS attacks are illegal without authorization
- Only test your own infrastructure or authorized targets
- Respect rate limits and terms of service

{Colors.GREEN}Target: {self.target or 'N/A'}{Colors.ENDC}
{Colors.GREEN}Person: {self.person or 'N/A'}{Colors.ENDC}
{Colors.GREEN}Authorized: {'YES' if self.authorized else 'NO - MUST CONFIRM'}{Colors.ENDC}
"""
        print(banner)
    
    def confirm_authorization(self, skip_prompt=False):
        """Confirm authorization for stress testing"""
        if self.authorized:
            print(f"{Colors.GREEN}[+] Authorization confirmed. Proceeding.{Colors.ENDC}\n")
            return True
        
        if skip_prompt:
            print(f"{Colors.CYAN}[*] Proceeding with OSINT gathering only (no stress testing).{Colors.ENDC}\n")
            return False
        
        print(f"\n{Colors.WARNING}=== AUTHORIZATION CONFIRMATION ==={Colors.ENDC}\n")
        print("OSINT gathering from public sources is generally legal.")
        print("However, stress testing requires EXPLICIT WRITTEN AUTHORIZATION.")
        print("\nDo you have authorization for:")
        print("  [+] Stress testing / DDoS simulation")
        print("  [+] Network penetration testing")
        print("  [+] Target system exploitation")
        
        try:
            response = input(f"\n{Colors.BOLD}Enter 'AUTHORIZED' to proceed with stress testing, or press Enter for OSINT only: {Colors.ENDC}")
            
            if response.strip() == 'AUTHORIZED':
                self.authorized = True
                print(f"{Colors.GREEN}[+] Authorization confirmed.{Colors.ENDC}\n")
                return True
            else:
                print(f"{Colors.CYAN}[*] Proceeding with OSINT gathering only (no stress testing).{Colors.ENDC}\n")
                return False
        except (EOFError, KeyboardInterrupt):
            print(f"{Colors.CYAN}[*] Proceeding with OSINT gathering only (no stress testing).{Colors.ENDC}\n")
            return False
    
    def log_finding(self, category, severity, description, data=None):
        """Log findings"""
        finding = {
            'category': category,
            'severity': severity,
            'description': description,
            'data': data,
            'timestamp': datetime.now().isoformat()
        }
        self.results['findings'].append(finding)
        
        color = {
            'CRITICAL': Colors.FAIL,
            'HIGH': Colors.WARNING,
            'MEDIUM': Colors.CYAN,
            'LOW': Colors.GREEN,
            'INFO': Colors.BLUE
        }.get(severity, Colors.ENDC)
        
        print(f"{color}[{severity}] {category}: {description}{Colors.ENDC}")
        if data:
            print(f"  -> {str(data)[:200]}")
        print()
    
    # ==================== DOMAIN RECONNAISSANCE ====================
    
    def domain_reconnaissance(self):
        """Comprehensive domain reconnaissance"""
        if not self.target:
            return
        
        print(f"\n{Colors.HEADER}=== DOMAIN RECONNAISSANCE ==={Colors.ENDC}\n")
        
        # DNS enumeration
        self.dns_enumeration()
        
        # Subdomain discovery
        self.subdomain_enumeration()
        
        # Technology detection
        self.technology_detection()
        
        # Certificate transparency
        self.certificate_transparency()
        
        # Historical data
        self.historical_data()
        
        # IP information
        self.ip_information()
    
    def dns_enumeration(self):
        """Enumerate DNS records"""
        print(f"{Colors.CYAN}[*] Enumerating DNS records...{Colors.ENDC}")
        
        record_types = ['A', 'AAAA', 'MX', 'NS', 'TXT', 'SOA', 'CNAME', 'SRV']
        
        for record_type in record_types:
            try:
                answers = dns.resolver.resolve(self.target, record_type)
                records = [str(rdata) for rdata in answers]
                
                for record in records:
                    self.log_finding('DNS', 'INFO', f'{record_type} record', record)
                    
                    # Extract IPs
                    if record_type == 'A':
                        if record not in self.results['ip_addresses']:
                            self.results['ip_addresses'].append(record)
                    
                    # Extract domains from MX/NS
                    if record_type in ['MX', 'NS']:
                        domain = record.split()[-1].rstrip('.')
                        if domain not in self.results['domains']:
                            self.results['domains'].append(domain)
            except:
                pass
    
    def subdomain_enumeration(self):
        """Comprehensive subdomain enumeration"""
        print(f"{Colors.CYAN}[*] Enumerating subdomains...{Colors.ENDC}")
        
        # Use consolidated subdomain list if available (generated by list_consolidator.py)
        if _HAS_CONSOLIDATED and CONSOLIDATED_SUBDOMAINS:
            subdomains = CONSOLIDATED_SUBDOMAINS
            print(f"  {Colors.CYAN}[+] Using consolidated subdomain list ({len(subdomains)} entries){Colors.ENDC}")
        else:
            # Fallback built-in subdomain wordlist
            subdomains = [
                'www', 'mail', 'ftp', 'admin', 'test', 'dev', 'staging', 'prod', 'production',
                'api', 'api2', 'api3', 'v1', 'v2', 'v3', 'portal', 'vpn', 'remote', 'cloud',
                'app', 'mobile', 'm', 'secure', 'ssl', 'webmail', 'email', 'smtp', 'pop',
                'ns1', 'ns2', 'dns', 'cdn', 'static', 'assets', 'media', 'images', 'img',
                'blog', 'news', 'forum', 'shop', 'store', 'cart', 'checkout', 'payment',
                'account', 'accounts', 'user', 'users', 'login', 'signin', 'auth', 'authz',
                'dashboard', 'panel', 'admin', 'administrator', 'root', 'sysadmin',
                'db', 'database', 'mysql', 'postgres', 'mongo', 'redis',
                'backup', 'backups', 'archive', 'old', 'legacy', 'temp', 'tmp',
                'test', 'testing', 'qa', 'staging', 'stage', 'dev', 'development',
                'internal', 'intranet', 'private', 'secure', 'vpn', 'remote',
                'monitor', 'monitoring', 'status', 'health', 'metrics', 'stats',
                'git', 'svn', 'svc', 'service', 'services', 'api-gateway',
                'order', 'orders', 'tracking', 'track', 'shipment', 'shipping',
                'customer', 'customers', 'client', 'clients', 'user', 'users',
                'support', 'help', 'docs', 'documentation', 'wiki', 'knowledge',
                'cms', 'content', 'upload', 'uploads', 'download', 'downloads',
                'files', 'file', 'storage', 's3', 'bucket', 'buckets'
            ]
        
        found = []
        
        def check_subdomain(sub):
            subdomain = f"{sub}.{self.target}"
            try:
                answers = dns.resolver.resolve(subdomain, 'A', lifetime=2)
                ips = [str(rdata) for rdata in answers]
                return (subdomain, ips[0])
            except:
                return None
        
        with ThreadPoolExecutor(max_workers=50) as executor:
            futures = {executor.submit(check_subdomain, sub): sub for sub in subdomains}
            for future in as_completed(futures):
                result = future.result()
                if result:
                    subdomain, ip = result
                    found.append((subdomain, ip))
                    self.log_finding('SUBDOMAIN', 'MEDIUM', f'Found: {subdomain}', ip)
                    if subdomain not in self.results['subdomains']:
                        self.results['subdomains'].append(subdomain)
    
    def technology_detection(self):
        """Detect technologies used"""
        print(f"{Colors.CYAN}[*] Detecting technologies...{Colors.ENDC}")
        
        base_urls = [f"https://{self.target}", f"http://{self.target}"]
        
        for base_url in base_urls:
            try:
                response = self.session.get(base_url, timeout=10, verify=False)
                
                # Server header
                if 'Server' in response.headers:
                    server = response.headers['Server']
                    self.log_finding('TECH', 'INFO', f'Server: {server}', None)
                    if server not in self.results['technologies']:
                        self.results['technologies'].append(server)
                
                # X-Powered-By
                if 'X-Powered-By' in response.headers:
                    powered = response.headers['X-Powered-By']
                    self.log_finding('TECH', 'INFO', f'Powered by: {powered}', None)
                    if powered not in self.results['technologies']:
                        self.results['technologies'].append(powered)
                
                # Framework detection
                html = response.text.lower()
                frameworks = {
                    'WordPress': ['wp-content', 'wp-includes', 'wordpress'],
                    'Drupal': ['drupal', 'sites/all'],
                    'Joomla': ['joomla', 'components/com_'],
                    'Laravel': ['laravel_session', 'csrf-token'],
                    'Django': ['csrfmiddlewaretoken', 'django'],
                    'React': ['react', 'react-dom'],
                    'Vue': ['vue.js', '__vue__'],
                    'Angular': ['ng-', 'angular'],
                    'Shopify': ['shopify', 'cdn.shopify'],
                    'Magento': ['magento', 'mage/']
                }
                
                for framework, indicators in frameworks.items():
                    if any(indicator in html for indicator in indicators):
                        self.log_finding('TECH', 'MEDIUM', f'Framework: {framework}', None)
                        if framework not in self.results['technologies']:
                            self.results['technologies'].append(framework)
                        break
            except:
                pass
    
    def certificate_transparency(self):
        """Check certificate transparency logs"""
        print(f"{Colors.CYAN}[*] Checking certificate transparency logs...{Colors.ENDC}")
        
        try:
            # Use crt.sh API
            url = f"https://crt.sh/?q=%.{self.target}&output=json"
            response = self.session.get(url, timeout=10)
            
            if response.status_code == 200:
                data = response.json()
                domains_found = set()
                
                for entry in data[:50]:  # Limit to 50
                    name = entry.get('name_value', '')
                    if name and self.target in name:
                        domains_found.add(name)
                
                for domain in list(domains_found)[:20]:
                    if domain not in self.results['domains']:
                        self.results['domains'].append(domain)
                        self.log_finding('CERT', 'INFO', f'Certificate domain: {domain}', None)
        except:
            pass
    
    def historical_data(self):
        """Gather historical data from Wayback Machine"""
        print(f"{Colors.CYAN}[*] Checking Wayback Machine...{Colors.ENDC}")
        
        try:
            url = f"http://web.archive.org/cdx/search/cdx?url={self.target}/*&output=json&limit=10"
            response = self.session.get(url, timeout=10)
            
            if response.status_code == 200:
                data = response.json()
                if len(data) > 1:
                    self.log_finding('HISTORY', 'INFO', f'Found {len(data)-1} historical snapshots', None)
        except:
            pass
    
    def ip_information(self):
        """Gather IP information"""
        print(f"{Colors.CYAN}[*] Gathering IP information...{Colors.ENDC}")
        
        try:
            target_ip = socket.gethostbyname(self.target)
            
            # Use ip-api.com (free, no key required)
            url = f"http://ip-api.com/json/{target_ip}"
            response = self.session.get(url, timeout=10)
            
            if response.status_code == 200:
                data = response.json()
                if data.get('status') == 'success':
                    info = {
                        'ip': data.get('query'),
                        'country': data.get('country'),
                        'region': data.get('regionName'),
                        'city': data.get('city'),
                        'isp': data.get('isp'),
                        'org': data.get('org'),
                        'as': data.get('as')
                    }
                    self.log_finding('IP', 'INFO', f'IP Information', info)
        except:
            pass
    
    # ==================== PEOPLE SEARCH ====================
    
    def people_search(self):
        """Comprehensive people search"""
        if not self.person:
            return
        
        print(f"\n{Colors.HEADER}=== PEOPLE SEARCH ==={Colors.ENDC}\n")
        
        # Email search
        self.email_search()
        
        # Social media search
        self.social_media_search()
        
        # Username search
        self.username_search()
        
        # Data breach search
        self.breach_search()
        
        # Phone number search
        self.phone_search()
    
    def email_search(self):
        """Search for email addresses"""
        print(f"{Colors.CYAN}[*] Searching for email addresses...{Colors.ENDC}")
        
        # Hunter.io API (requires API key, but we'll try free methods)
        # Try common email patterns
        domains = [self.target] if self.target else ['gmail.com', 'yahoo.com', 'outlook.com']
        
        common_patterns = [
            f"{self.person.lower().replace(' ', '.')}",
            f"{self.person.lower().replace(' ', '_')}",
            f"{self.person.split()[0].lower()}.{self.person.split()[-1].lower()}",
            f"{self.person.split()[0].lower()}{self.person.split()[-1].lower()}",
            f"{self.person.split()[0][0].lower()}{self.person.split()[-1].lower()}",
        ]
        
        for domain in domains:
            for pattern in common_patterns:
                email = f"{pattern}@{domain}"
                # Verify email (basic check)
                if re.match(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$', email):
                    if email not in self.results['emails']:
                        self.results['emails'].append(email)
                        self.log_finding('EMAIL', 'MEDIUM', f'Possible email: {email}', None)
    
    def social_media_search(self):
        """Search social media platforms"""
        print(f"{Colors.CYAN}[*] Searching social media platforms...{Colors.ENDC}")
        
        platforms = {
            'LinkedIn': f"https://www.linkedin.com/search/results/people/?keywords={quote(self.person)}",
            'Twitter': f"https://twitter.com/search?q={quote(self.person)}",
            'Facebook': f"https://www.facebook.com/search/people/?q={quote(self.person)}",
            'Instagram': f"https://www.instagram.com/{self.person.replace(' ', '').lower()}/",
            'GitHub': f"https://github.com/{self.person.replace(' ', '').lower()}",
        }
        
        for platform, url in platforms.items():
            try:
                response = self.session.get(url, timeout=5, allow_redirects=False)
                if response.status_code in [200, 301, 302]:
                    if platform not in self.results['social_media']:
                        self.results['social_media'][platform] = url
                        self.log_finding('SOCIAL', 'INFO', f'{platform} profile found', url)
            except:
                pass
    
    def username_search(self):
        """Search for usernames across platforms"""
        print(f"{Colors.CYAN}[*] Searching for usernames...{Colors.ENDC}")
        
        # Common username patterns
        username_patterns = [
            self.person.replace(' ', '').lower(),
            self.person.replace(' ', '_').lower(),
            self.person.replace(' ', '.').lower(),
            self.person.split()[0].lower() + self.person.split()[-1].lower(),
        ]
        
        platforms = [
            'github.com',
            'twitter.com',
            'instagram.com',
            'reddit.com/user',
            'youtube.com/user',
            'tiktok.com/@'
        ]
        
        for username in username_patterns[:2]:  # Limit to avoid too many requests
            for platform in platforms[:3]:  # Limit platforms
                url = f"https://{platform}/{username}"
                try:
                    response = self.session.get(url, timeout=5, allow_redirects=False)
                    if response.status_code == 200:
                        self.log_finding('USERNAME', 'MEDIUM', f'Possible username: {username} on {platform}', url)
                except:
                    pass
    
    def breach_search(self):
        """Search data breach databases"""
        print(f"{Colors.CYAN}[*] Checking data breach databases...{Colors.ENDC}")
        
        # Have I Been Pwned API (requires email, so we'll use the emails we found)
        for email in self.results['emails']:
            try:
                # HIBP API (free tier)
                url = f"https://haveibeenpwned.com/api/v3/breachedaccount/{email}"
                headers = {'hibp-api-key': ''}  # Would need API key for v3
                # For demo, we'll use v2 (no key required but limited)
                url = f"https://haveibeenpwned.com/api/v2/breachedaccount/{email}"
                response = self.session.get(url, timeout=10, headers={'User-Agent': 'OSINT-Tool'})
                
                if response.status_code == 200:
                    breaches = response.json()
                    for breach in breaches:
                        breach_info = {
                            'name': breach.get('Name'),
                            'domain': breach.get('Domain'),
                            'breach_date': breach.get('BreachDate'),
                            'pwn_count': breach.get('PwnCount')
                        }
                        self.results['breaches'].append(breach_info)
                        self.log_finding('BREACH', 'HIGH', f'Email found in breach: {breach.get("Name")}', breach_info)
            except:
                pass
    
    def phone_search(self):
        """Search for phone numbers"""
        print(f"{Colors.CYAN}[*] Searching for phone numbers...{Colors.ENDC}")
        
        # This would typically require paid services
        # For demo, we'll show the structure
        self.log_finding('PHONE', 'INFO', 'Phone search requires paid API access', 'Consider: TrueCaller API, WhitePages API')
    
    # ==================== STRESS TESTING / DDoS ====================
    
    def stress_test(self, target_url, duration=60, threads=10):
        """Network stress testing (AUTHORIZED TARGETS ONLY)"""
        if not self.authorized:
            print(f"{Colors.FAIL}[-] Stress testing requires authorization!{Colors.ENDC}")
            return
        
        print(f"\n{Colors.HEADER}=== STRESS TESTING (AUTHORIZED ONLY) ==={Colors.ENDC}\n")
        print(f"{Colors.WARNING}[!] WARNING: This will send high-volume traffic to {target_url}{Colors.ENDC}")
        print(f"{Colors.WARNING}[!] Only use on authorized targets!{Colors.ENDC}\n")
        
        confirm = input(f"{Colors.BOLD}Type 'CONFIRM' to proceed: {Colors.ENDC}")
        if confirm != 'CONFIRM':
            print(f"{Colors.FAIL}[-] Stress test cancelled.{Colors.ENDC}")
            return
        
        print(f"{Colors.CYAN}[*] Starting stress test for {duration} seconds...{Colors.ENDC}\n")
        
        stats = {
            'requests_sent': 0,
            'successful': 0,
            'failed': 0,
            'start_time': time.time()
        }
        
        def attack_worker():
            while time.time() - stats['start_time'] < duration:
                try:
                    response = self.session.get(target_url, timeout=5, verify=False)
                    stats['requests_sent'] += 1
                    if response.status_code == 200:
                        stats['successful'] += 1
                    else:
                        stats['failed'] += 1
                except:
                    stats['requests_sent'] += 1
                    stats['failed'] += 1
                time.sleep(0.1)  # Small delay to avoid overwhelming
        
        # Start attack threads
        threads_list = []
        for i in range(threads):
            t = threading.Thread(target=attack_worker)
            t.daemon = True
            t.start()
            threads_list.append(t)
        
        # Monitor progress
        while time.time() - stats['start_time'] < duration:
            elapsed = int(time.time() - stats['start_time'])
            print(f"\r{Colors.CYAN}[*] Elapsed: {elapsed}s | Requests: {stats['requests_sent']} | Success: {stats['successful']} | Failed: {stats['failed']}{Colors.ENDC}", end='')
            time.sleep(1)
        
        # Wait for threads
        for t in threads_list:
            t.join(timeout=1)
        
        print(f"\n\n{Colors.GREEN}[+] Stress test complete!{Colors.ENDC}")
        print(f"  Total requests: {stats['requests_sent']}")
        print(f"  Successful: {stats['successful']}")
        print(f"  Failed: {stats['failed']}")
        print(f"  Requests/sec: {stats['requests_sent'] / duration:.2f}")
        
        self.results['stress_test'] = stats
    
    def generate_report(self, output_file=None):
        """Generate comprehensive report"""
        if output_file is None:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            target_name = (self.target or self.person or 'recon').replace('.', '_')
            output_file = f"osint_report_{target_name}_{timestamp}.json"
        
        self.results['summary'] = {
            'total_findings': len(self.results['findings']),
            'emails_found': len(self.results['emails']),
            'phone_numbers_found': len(self.results['phone_numbers']),
            'subdomains_found': len(self.results['subdomains']),
            'domains_found': len(self.results['domains']),
            'ip_addresses_found': len(self.results['ip_addresses']),
            'technologies_found': len(self.results['technologies']),
            'social_media_profiles': len(self.results['social_media']),
            'breaches_found': len(self.results['breaches'])
        }
        
        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump(self.results, f, indent=2, ensure_ascii=False)
        
        print(f"\n{Colors.GREEN}===============================================================")
        print(f"              REPORT GENERATION COMPLETE")
        print(f"==============================================================={Colors.ENDC}\n")
        print(f"Report saved to: {output_file}")
        
        # Print summary
        summary = self.results['summary']
        print(f"\n{Colors.BOLD}SUMMARY:{Colors.ENDC}")
        print(f"  Total Findings: {summary['total_findings']}")
        print(f"  Emails: {summary['emails_found']}")
        print(f"  Subdomains: {summary['subdomains_found']}")
        print(f"  Domains: {summary['domains_found']}")
        print(f"  IP Addresses: {summary['ip_addresses_found']}")
        print(f"  Technologies: {summary['technologies_found']}")
        print(f"  Social Media: {summary['social_media_profiles']}")
        print(f"  Data Breaches: {summary['breaches_found']}")
        
        return output_file


def main():
    print(f"""
{Colors.CYAN}FLLC - OSINT & Reconnaissance Suite{Colors.ENDC}

Usage:
  python osint_recon_suite.py --target <domain> [--authorized]
  python osint_recon_suite.py --person "<name>" [--target <domain>]
  python osint_recon_suite.py --stress <url> --authorized

Examples:
  python osint_recon_suite.py --target fllc.net
  python osint_recon_suite.py --person "John Doe" --target company.com
  python osint_recon_suite.py --stress https://example.com --authorized

{Colors.WARNING}[!] Always obtain authorization for stress testing!{Colors.ENDC}
""")
    
    if len(sys.argv) < 2:
        sys.exit(1)
    
    target = None
    person = None
    stress_url = None
    authorized = '--authorized' in sys.argv
    
    # Parse arguments
    i = 1
    while i < len(sys.argv):
        if sys.argv[i] == '--target' and i + 1 < len(sys.argv):
            target = sys.argv[i + 1]
            i += 2
        elif sys.argv[i] == '--person' and i + 1 < len(sys.argv):
            person = sys.argv[i + 1]
            i += 2
        elif sys.argv[i] == '--stress' and i + 1 < len(sys.argv):
            stress_url = sys.argv[i + 1]
            i += 2
        else:
            i += 1
    
    suite = OSINTReconSuite(target=target, person=person, authorized=authorized)
    suite.print_banner()
    
    if stress_url:
        suite.confirm_authorization()
        suite.stress_test(stress_url, duration=60, threads=10)
    else:
        # Skip prompt for OSINT-only operations
        suite.confirm_authorization(skip_prompt=True)
        
        if target:
            suite.domain_reconnaissance()
        
        if person:
            suite.people_search()
        
        if not target and not person:
            print(f"{Colors.FAIL}[-] Please specify --target or --person{Colors.ENDC}")
            sys.exit(1)
    
    # Generate report
    suite.generate_report()
    
    print(f"\n{Colors.GREEN}[+] Reconnaissance complete!{Colors.ENDC}\n")


if __name__ == '__main__':
    main()
